{"graph": {"directed": true, "nodes": {"node_6ab514fc": {"uid": "node_6ab514fc", "label": "276: _acquire_asyncio_semaphore()", "name": "helpers::_acquire_asyncio_semaphore", "parent": "helpers", "is_leaf": true, "is_trunk": false, "source_code": "async def _acquire_asyncio_semaphore(\n    semaphore: asyncio.Semaphore,\n    sem_timeout: float,\n    sem_key: str,\n    semaphore_lax: bool,\n    semaphore_limit: int,\n    timeout: float,\n    sem_start: float,\n) -> bool:\n    \"\"\"Acquire an asyncio semaphore.\"\"\"\n    try:\n        async with asyncio.timeout(sem_timeout):\n            await semaphore.acquire()\n            return True\n    except TimeoutError:\n        sem_wait_time = time.time() - sem_start\n        if not semaphore_lax:\n            raise TimeoutError(\n                f'Failed to acquire semaphore \"{sem_key}\" within {sem_timeout}s '\n                f'(limit={semaphore_limit}, timeout={timeout}s per operation)'\n            )\n        logger.warning(\n            f'Failed to acquire semaphore \"{sem_key}\" after {sem_wait_time:.1f}s, proceeding without concurrency limit'\n        )\n        return False", "variables": []}, "node_26a84f5a": {"uid": "node_26a84f5a", "label": "215: _acquire_multiprocess_semaphore()", "name": "helpers::_acquire_multiprocess_semaphore", "parent": "helpers", "is_leaf": true, "is_trunk": false, "source_code": "async def _acquire_multiprocess_semaphore(\n    semaphore: Any,\n    sem_timeout: float,\n    sem_key: str,\n    semaphore_lax: bool,\n    semaphore_limit: int,\n    timeout: float,\n) -> tuple[bool, Any]:\n    \"\"\"Acquire a multiprocess semaphore with retries and exponential backoff.\"\"\"\n    start_time = time.time()\n    retry_delay = 0.1  # Start with 100ms\n    backoff_factor = 2.0\n    max_single_attempt = 1.0  # Max time for a single acquire attempt\n\n    while time.time() - start_time < sem_timeout:\n        try:\n            # Calculate remaining time\n            remaining_time = sem_timeout - (time.time() - start_time)\n            if remaining_time <= 0:\n                break\n\n            # Use minimum of remaining time or max single attempt\n            attempt_timeout = min(remaining_time, max_single_attempt)\n\n            # Use a temporary thread to run the blocking operation\n            multiprocess_lock = await asyncio.to_thread(\n                lambda: semaphore.acquire(timeout=attempt_timeout, check_interval=0.1, fail_when_locked=False)\n            )\n            if multiprocess_lock:\n                return True, multiprocess_lock\n\n            # If we didn't get the lock, wait before retrying\n            if remaining_time > retry_delay:\n                await asyncio.sleep(retry_delay)\n                retry_delay = min(retry_delay * backoff_factor, 1.0)  # Cap at 1 second\n\n        except (AssertionError, Exception) as e:\n            # Handle \"Already locked\" error by skipping this attempt\n            if 'Already locked' in str(e) or isinstance(e, AssertionError):\n                # Lock file might be stale from a previous process crash\n                # Wait before retrying\n                remaining_time = sem_timeout - (time.time() - start_time)\n                if remaining_time > retry_delay:\n                    await asyncio.sleep(retry_delay)\n                    retry_delay = min(retry_delay * backoff_factor, 1.0)\n                continue\n            elif 'Could not acquire' not in str(e) and not isinstance(e, TimeoutError):\n                raise\n\n    # Timeout reached\n    if not semaphore_lax:\n        raise TimeoutError(\n            f'Failed to acquire multiprocess semaphore \"{sem_key}\" within {sem_timeout}s '\n            f'(limit={semaphore_limit}, timeout={timeout}s per operation)'\n        )\n    logger.warning(\n        f'Failed to acquire multiprocess semaphore \"{sem_key}\" after {sem_timeout:.1f}s, proceeding without concurrency limit'\n    )\n    return False, None", "variables": ["start_time-><Call owner_token=time token=time>", "attempt_timeout-><Call owner_token=None token=min>", "retry_delay-><Call owner_token=None token=min>", "retry_delay-><Call owner_token=None token=min>"]}, "node_6ef5fab2": {"uid": "node_6ef5fab2", "label": "200: _calculate_semaphore_timeout()", "name": "helpers::_calculate_semaphore_timeout", "parent": "helpers", "is_leaf": true, "is_trunk": false, "source_code": "def _calculate_semaphore_timeout(\n    semaphore_timeout: float | None,\n    timeout: float,\n    semaphore_limit: int,\n) -> float:\n    \"\"\"Calculate the timeout for semaphore acquisition.\"\"\"\n    if semaphore_timeout is None:\n        # Default: wait time is if all other slots are occupied with max timeout operations\n        # Ensure minimum of timeout value when limit=1\n        return max(timeout, timeout * (semaphore_limit - 1))\n    else:\n        # Use provided timeout, but ensure minimum of 0.01 if 0 was passed\n        return max(0.01, semaphore_timeout) if semaphore_timeout == 0 else semaphore_timeout", "variables": []}, "node_373f1430": {"uid": "node_373f1430", "label": "90: _check_system_overload()", "name": "helpers::_check_system_overload", "parent": "helpers", "is_leaf": true, "is_trunk": false, "source_code": "def _check_system_overload() -> tuple[bool, str]:\n    \"\"\"Check if system is overloaded and return (is_overloaded, reason)\"\"\"\n    if not PSUTIL_AVAILABLE:\n        return False, ''\n\n    assert psutil is not None\n    try:\n        # Get system stats\n        cpu_percent = psutil.cpu_percent(interval=0.1)\n        memory = psutil.virtual_memory()\n\n        # Check thresholds\n        reasons: list[str] = []\n        is_overloaded = False\n\n        if cpu_percent > 85:\n            is_overloaded = True\n            reasons.append(f'CPU: {cpu_percent:.1f}%')\n\n        if memory.percent > 85:\n            is_overloaded = True\n            reasons.append(f'Memory: {memory.percent:.1f}%')\n\n        # Check number of concurrent operations\n        with _active_operations_lock:\n            if _active_retry_operations > 30:\n                is_overloaded = True\n                reasons.append(f'Active operations: {_active_retry_operations}')\n\n        return is_overloaded, ', '.join(reasons)\n    except Exception:\n        return False, ''", "variables": ["cpu_percent-><Call owner_token=psutil token=cpu_percent>", "memory-><Call owner_token=psutil token=virtual_memory>"]}, "node_aa4ef5eb": {"uid": "node_aa4ef5eb", "label": "370: _check_system_overload_if_needed()", "name": "helpers::_check_system_overload_if_needed", "parent": "helpers", "is_leaf": false, "is_trunk": false, "source_code": "def _check_system_overload_if_needed() -> None:\n    \"\"\"Check for system overload if enough time has passed since last check.\"\"\"\n    global _last_overload_check\n    current_time = time.time()\n    if current_time - _last_overload_check > _overload_check_interval:\n        _last_overload_check = current_time\n        is_overloaded, reason = _check_system_overload()\n        if is_overloaded:\n            logger.warning(f'\u26a0\ufe0f  System overload detected: {reason}. Consider reducing concurrent operations to prevent hanging.')", "variables": ["current_time-><Call owner_token=time token=time>"]}, "node_1783601c": {"uid": "node_1783601c", "label": "303: _execute_with_retries()", "name": "helpers::_execute_with_retries", "parent": "helpers", "is_leaf": true, "is_trunk": false, "source_code": "async def _execute_with_retries(\n    func: Callable[P, Coroutine[Any, Any, T]],\n    args: P.args,  # type: ignore\n    kwargs: P.kwargs,  # type: ignore\n    retries: int,\n    timeout: float,\n    wait: float,\n    backoff_factor: float,\n    retry_on: tuple[type[Exception], ...] | None,\n    start_time: float,\n    sem_start: float,\n    semaphore_limit: int | None,\n) -> T:\n    \"\"\"Execute the function with retry logic.\"\"\"\n    for attempt in range(retries + 1):\n        try:\n            # Execute with per-attempt timeout\n            async with asyncio.timeout(timeout):\n                return await func(*args, **kwargs)  # type: ignore[reportCallIssue]\n\n        except Exception as e:\n            # Check if we should retry this exception\n            if retry_on is not None and not isinstance(e, retry_on):\n                raise\n\n            if attempt < retries:\n                # Calculate wait time with backoff\n                current_wait = wait * (backoff_factor**attempt)\n\n                # Only log warning on the final retry attempt (second-to-last overall attempt)\n                if attempt == retries - 1:\n                    logger.warning(\n                        f'{func.__name__} failed (attempt {attempt + 1}/{retries + 1}): '\n                        f'{type(e).__name__}: {e}. Waiting {current_wait:.1f}s before retry...'\n                    )\n                # else:\n                #     # For earlier attempts, skip logging to reduce noise\n                #     logger.debug(\n                #         f'{func.__name__} failed (attempt {attempt + 1}/{retries + 1}): '\n                #         f'{type(e).__name__}: {e}. Waiting {current_wait:.1f}s before retry...'\n                #     )\n                await asyncio.sleep(current_wait)\n            else:\n                # Final failure\n                total_time = time.time() - start_time\n                sem_wait = time.time() - sem_start - total_time if semaphore_limit else 0\n\n                logger.error(\n                    f'{func.__name__} failed after {retries + 1} attempts over {total_time:.1f}s. '\n                    f'Semaphore wait: {sem_wait:.1f}s. Final error: {type(e).__name__}: {e}'\n                )\n                raise\n\n    # This should never be reached, but satisfies type checker\n    raise RuntimeError('Unexpected state in retry logic')", "variables": []}, "node_11b04846": {"uid": "node_11b04846", "label": "148: _get_or_create_semaphore()", "name": "helpers::_get_or_create_semaphore", "parent": "helpers", "is_leaf": true, "is_trunk": false, "source_code": "def _get_or_create_semaphore(\n    sem_key: str,\n    semaphore_limit: int,\n    semaphore_scope: Literal['multiprocess', 'global', 'class', 'self'],\n) -> Any:\n    \"\"\"Get or create a semaphore based on scope.\"\"\"\n    if semaphore_scope == 'multiprocess':\n        # Don't cache multiprocess semaphores - they have internal state issues\n        # Create a new instance each time to avoid \"Already locked\" errors\n        with MULTIPROCESS_SEMAPHORE_LOCK:\n            # Ensure the directory exists (it might have been cleaned up in cloud environments)\n            MULTIPROCESS_SEMAPHORE_DIR.mkdir(exist_ok=True, parents=True)\n\n            # Clean up any stale lock files before creating semaphore\n            lock_pattern = f'{sem_key}.*.lock'\n            for lock_file in MULTIPROCESS_SEMAPHORE_DIR.glob(lock_pattern):\n                try:\n                    # Try to remove lock files older than 5 minutes\n                    if lock_file.stat().st_mtime < time.time() - 300:\n                        lock_file.unlink(missing_ok=True)\n                except Exception:\n                    pass  # Ignore errors when cleaning up\n\n            # Use a more aggressive timeout for lock acquisition\n            try:\n                semaphore = portalocker.utils.NamedBoundedSemaphore(\n                    maximum=semaphore_limit,\n                    name=sem_key,\n                    directory=str(MULTIPROCESS_SEMAPHORE_DIR),\n                    timeout=0.1,  # Very short timeout for internal lock acquisition\n                )\n                return semaphore\n            except FileNotFoundError as e:\n                # In some cloud environments, the lock file creation might fail\n                # Try once more after ensuring directory exists\n                logger.warning(f'Lock file creation failed: {e}. Retrying after ensuring directory exists.')\n                MULTIPROCESS_SEMAPHORE_DIR.mkdir(exist_ok=True, parents=True)\n\n                # Create a fallback asyncio semaphore instead of multiprocess\n                logger.warning(f'Falling back to asyncio semaphore for {sem_key} due to filesystem issues')\n                with GLOBAL_RETRY_SEMAPHORE_LOCK:\n                    fallback_key = f'multiprocess_fallback_{sem_key}'\n                    if fallback_key not in GLOBAL_RETRY_SEMAPHORES:\n                        GLOBAL_RETRY_SEMAPHORES[fallback_key] = asyncio.Semaphore(semaphore_limit)\n                    return GLOBAL_RETRY_SEMAPHORES[fallback_key]\n    else:\n        with GLOBAL_RETRY_SEMAPHORE_LOCK:\n            if sem_key not in GLOBAL_RETRY_SEMAPHORES:\n                GLOBAL_RETRY_SEMAPHORES[sem_key] = asyncio.Semaphore(semaphore_limit)\n            return GLOBAL_RETRY_SEMAPHORES[sem_key]", "variables": ["semaphore-><Call owner_token=portalocker token=NamedBoundedSemaphore>"]}, "node_d6660ac4": {"uid": "node_d6660ac4", "label": "124: _get_semaphore_key()", "name": "helpers::_get_semaphore_key", "parent": "helpers", "is_leaf": true, "is_trunk": false, "source_code": "def _get_semaphore_key(\n    func_name: str,\n    semaphore_name: str | None,\n    semaphore_scope: Literal['multiprocess', 'global', 'class', 'self'],\n    args: tuple[Any, ...],\n) -> str:\n    \"\"\"Determine the semaphore key based on scope.\"\"\"\n    base_name = semaphore_name or func_name\n\n    if semaphore_scope == 'multiprocess':\n        return base_name\n    elif semaphore_scope == 'global':\n        return base_name\n    elif semaphore_scope == 'class' and args and hasattr(args[0], '__class__'):\n        class_name = args[0].__class__.__name__\n        return f'{class_name}.{base_name}'\n    elif semaphore_scope == 'self' and args:\n        instance_id = id(args[0])\n        return f'{instance_id}.{base_name}'\n    else:\n        # Fallback to global if we can't determine scope\n        return base_name", "variables": ["instance_id-><Call owner_token=None token=id>"]}, "node_0bcbb603": {"uid": "node_0bcbb603", "label": "360: _track_active_operations()", "name": "helpers::_track_active_operations", "parent": "helpers", "is_leaf": true, "is_trunk": false, "source_code": "def _track_active_operations(increment: bool = True) -> None:\n    \"\"\"Track active retry operations.\"\"\"\n    global _active_retry_operations\n    with _active_operations_lock:\n        if increment:\n            _active_retry_operations += 1\n        else:\n            _active_retry_operations = max(0, _active_retry_operations - 1)", "variables": ["_active_retry_operations-><Call owner_token=None token=max>"]}, "node_f4ddb094": {"uid": "node_f4ddb094", "label": "381: retry()", "name": "helpers::retry", "parent": "helpers", "is_leaf": false, "is_trunk": false, "source_code": "def retry(\n    wait: float = 3,\n    retries: int = 3,\n    timeout: float = 5,\n    retry_on: tuple[type[Exception], ...] | None = None,\n    backoff_factor: float = 1.0,\n    semaphore_limit: int | None = None,\n    semaphore_name: str | None = None,\n    semaphore_lax: bool = True,\n    semaphore_scope: Literal['multiprocess', 'global', 'class', 'self'] = 'global',\n    semaphore_timeout: float | None = None,\n):\n    \"\"\"\n        Retry decorator with semaphore support for async functions.\n\n        Args:\n                wait: Seconds to wait between retries\n                retries: Number of retry attempts after initial failure\n                timeout: Per-attempt timeout in seconds\n                retry_on: Tuple of exception types to retry on (None = retry all exceptions)\n                backoff_factor: Multiplier for wait time after each retry (1.0 = no backoff)\n                semaphore_limit: Max concurrent executions (creates semaphore if needed)\n                semaphore_name: Name for semaphore (defaults to function name)\n                semaphore_lax: If True, continue without semaphore on acquisition failure\n                semaphore_scope: Scope for semaphore sharing:\n                        - 'global': All calls share one semaphore (default)\n                        - 'class': All instances of a class share one semaphore\n                        - 'self': Each instance gets its own semaphore\n                        - 'multiprocess': All processes on the machine share one semaphore\n                semaphore_timeout: Max time to wait for semaphore acquisition (None = timeout * (limit - 1)) or 0.01s\n\n        Example:\n                @retry(wait=3, retries=3, timeout=5, semaphore_limit=3, semaphore_scope='self')\n                async def some_function(self, ...):\n                        # Limited to 5s per attempt, retries up to 3 times on failure\n                        # Max 3 concurrent executions per instance\n\n    Notes:\n                - semaphore aquision happens once at start time, it's not retried\n                - semaphore_timeout is only used if semaphore_limit is set.\n                - if semaphore_timeout is set to 0, it will wait forever for a semaphore slot to become available.\n                - if semaphore_timeout is set to None, it will wait for the default (timeout * (semaphore_limit - 1)) +0.01s\n                - retries are 0-indexed, so retries=1 means the function will be called 2 times total (1 initial + 1 retry)\n    \"\"\"\n\n    def decorator(func: Callable[P, Coroutine[Any, Any, T]]) -> Callable[P, Coroutine[Any, Any, T]]:\n        @wraps(func)\n        async def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:  # type: ignore[return]\n            # Initialize semaphore-related variables\n            semaphore: Any = None\n            semaphore_acquired = False\n            multiprocess_lock: Any = None\n            sem_start = time.time()\n\n            # Handle semaphore if specified\n            if semaphore_limit is not None:\n                # Get semaphore key and create/retrieve semaphore\n                sem_key = _get_semaphore_key(func.__name__, semaphore_name, semaphore_scope, args)\n                semaphore = _get_or_create_semaphore(sem_key, semaphore_limit, semaphore_scope)\n\n                # Calculate timeout for semaphore acquisition\n                sem_timeout = _calculate_semaphore_timeout(semaphore_timeout, timeout, semaphore_limit)\n\n                # Acquire semaphore based on type\n                if semaphore_scope == 'multiprocess':\n                    semaphore_acquired, multiprocess_lock = await _acquire_multiprocess_semaphore(\n                        semaphore, sem_timeout, sem_key, semaphore_lax, semaphore_limit, timeout\n                    )\n                else:\n                    semaphore_acquired = await _acquire_asyncio_semaphore(\n                        semaphore, sem_timeout, sem_key, semaphore_lax, semaphore_limit, timeout, sem_start\n                    )\n\n            # Track active operations and check system overload\n            _track_active_operations(increment=True)\n            _check_system_overload_if_needed()\n\n            # Execute function with retries\n            start_time = time.time()\n            try:\n                return await _execute_with_retries(\n                    func, args, kwargs, retries, timeout, wait, backoff_factor, retry_on, start_time, sem_start, semaphore_limit\n                )\n            finally:\n                # Clean up: decrement active operations and release semaphore\n                _track_active_operations(increment=False)\n\n                if semaphore_acquired and semaphore:\n                    if semaphore_scope == 'multiprocess' and multiprocess_lock:\n                        await asyncio.to_thread(lambda: multiprocess_lock.release())\n                    elif semaphore:\n                        semaphore.release()\n\n        return wrapper\n\n    return decorator", "variables": ["sem_start-><Call owner_token=time token=time>", "start_time-><Call owner_token=time token=time>", "sem_key-><Call owner_token=None token=_get_semaphore_key>", "semaphore-><Call owner_token=None token=_get_or_create_semaphore>", "sem_timeout-><Call owner_token=None token=_calculate_semaphore_timeout>"]}, "node_f06114ab": {"uid": "node_f06114ab", "label": "19: format_result_value()", "name": "logging::format_result_value", "parent": "logging", "is_leaf": true, "is_trunk": false, "source_code": "def format_result_value(value: Any) -> str:\n    \"\"\"Format a result value for display\"\"\"\n    if value is None:\n        return 'None'\n    if hasattr(value, 'event_type') and hasattr(value, 'event_id'):  # BaseEvent check without import\n        return f'Event({value.event_type}#{value.event_id[-4:]})'\n    if isinstance(value, (str, int, float, bool)):\n        return repr(value)\n    if isinstance(value, dict):\n        return f'dict({len(value)} items)'  # type: ignore[arg-type]\n    if isinstance(value, list):\n        return f'list({len(value)} items)'  # type: ignore[arg-type]\n    return f'{type(value).__name__}(...)'", "variables": []}, "node_a5437ae5": {"uid": "node_a5437ae5", "label": "12: format_timestamp()", "name": "logging::format_timestamp", "parent": "logging", "is_leaf": true, "is_trunk": false, "source_code": "def format_timestamp(dt: datetime | None) -> str:\n    \"\"\"Format a datetime for display\"\"\"\n    if dt is None:\n        return 'N/A'\n    return dt.strftime('%H:%M:%S.%f')[:-3]", "variables": []}, "node_0c9dcba2": {"uid": "node_0c9dcba2", "label": "34: log_event_tree()", "name": "logging::log_event_tree", "parent": "logging", "is_leaf": false, "is_trunk": false, "source_code": "def log_event_tree(\n    event: 'BaseEvent',\n    indent: str = '',\n    is_last: bool = True,\n    child_events_by_parent: dict[str | None, list['BaseEvent']] | None = None,\n) -> None:\n    \"\"\"Print this event and its results with proper tree formatting\"\"\"\n    # Determine the connector\n    connector = '\u2514\u2500\u2500 ' if is_last else '\u251c\u2500\u2500 '\n\n    # Print this event's line\n    status_icon = '\u2705' if event.event_status == 'completed' else '\ud83c\udfc3' if event.event_status == 'started' else '\u23f3'\n\n    # Format timing info\n    timing_str = f'[{format_timestamp(event.event_created_at)}'\n    if event.event_completed_at and event.event_created_at:\n        duration = (event.event_completed_at - event.event_created_at).total_seconds()\n        timing_str += f' ({duration:.3f}s)'\n    timing_str += ']'\n\n    print(f'{indent}{connector}{status_icon} {event.event_type}#{event.event_id[-4:]} {timing_str}')\n\n    # Calculate the new indent for children\n    extension = '    ' if is_last else '\u2502   '\n    new_indent = indent + extension\n\n    # Track which child events were printed via handlers to avoid duplicates\n    printed_child_ids: set[str] = set()\n\n    # Print each result\n    if event.event_results:\n        results_sorted = sorted(event.event_results.items(), key=lambda x: x[1].started_at or datetime.min.replace(tzinfo=UTC))\n\n        # Calculate which is the last item considering both results and unmapped children\n        unmapped_children: list[BaseEvent] = []\n        if child_events_by_parent:\n            all_children = child_events_by_parent.get(event.event_id, [])\n            for child in all_children:\n                # Will be printed later if not already printed by a handler\n                if child.event_id not in [c.event_id for r in event.event_results.values() for c in r.event_children]:\n                    unmapped_children.append(child)\n\n        total_items = len(results_sorted) + len(unmapped_children)\n\n        for i, (_handler_id, result) in enumerate(results_sorted):\n            is_last_item = i == total_items - 1\n            log_eventresult_tree(result, new_indent, is_last_item, child_events_by_parent)\n            # Track child events printed by this result\n            for child in result.event_children:\n                printed_child_ids.add(child.event_id)\n\n    # Print unmapped children (those not printed by any handler)\n    if child_events_by_parent:\n        children = child_events_by_parent.get(event.event_id, [])\n        for i, child in enumerate(children):\n            if child.event_id not in printed_child_ids:\n                is_last_child = i == len(children) - 1\n                log_event_tree(child, new_indent, is_last_child, child_events_by_parent)", "variables": ["duration-><Call owner_token=UNKNOWN_VAR token=total_seconds>", "results_sorted-><Call owner_token=None token=sorted>", "all_children-><Call owner_token=child_events_by_parent token=get>", "children-><Call owner_token=child_events_by_parent token=get>"]}, "node_5e3f8add": {"uid": "node_5e3f8add", "label": "148: log_eventbus_tree()", "name": "logging::log_eventbus_tree", "parent": "logging", "is_leaf": false, "is_trunk": false, "source_code": "def log_eventbus_tree(eventbus: 'EventBus') -> None:\n    \"\"\"Print a nice pretty formatted tree view of all events in the history including their results and child events recursively\"\"\"\n\n    # Build a mapping of parent_id to child events\n    parent_to_children: dict[str | None, list['BaseEvent']] = defaultdict(list)\n    for event in eventbus.event_history.values():\n        parent_to_children[event.event_parent_id].append(event)\n\n    # Sort events by creation time\n    for children in parent_to_children.values():\n        children.sort(key=lambda e: e.event_created_at)\n\n    # Find root events (those without parents or with self as parent)\n    root_events = list(parent_to_children[None])\n\n    # Also include events that have themselves as parent (edge case)\n    for event in eventbus.event_history.values():\n        if event.event_parent_id == event.event_id and event not in root_events:\n            root_events.append(event)\n            # Remove from its incorrect parent mapping to avoid double printing\n            if event.event_id in parent_to_children:\n                parent_to_children[event.event_id] = [\n                    e for e in parent_to_children[event.event_id] if e.event_id != event.event_id\n                ]\n\n    print(f'\\n\ud83d\udcca Event History Tree for {eventbus}')\n    print('=' * 80)\n\n    if not root_events:\n        print('  (No events in history)')\n        return\n\n    # Print all root events using their log_tree helper method\n    for i, event in enumerate(root_events):\n        is_last = i == len(root_events) - 1\n        log_event_tree(event, '', is_last, parent_to_children)\n\n    print('=' * 80)", "variables": ["root_events-><Call owner_token=None token=list>"]}, "node_28018a59": {"uid": "node_28018a59", "label": "94: log_eventresult_tree()", "name": "logging::log_eventresult_tree", "parent": "logging", "is_leaf": false, "is_trunk": false, "source_code": "def log_eventresult_tree(\n    result: 'EventResult',\n    indent: str = '',\n    is_last: bool = True,\n    child_events_by_parent: dict[str | None, list['BaseEvent']] | None = None,\n) -> None:\n    \"\"\"Print this result and its child events with proper tree formatting\"\"\"\n    # Determine the connector\n    connector = '\u2514\u2500\u2500 ' if is_last else '\u251c\u2500\u2500 '\n\n    # Status icon\n    result_icon = (\n        '\u2705'\n        if result.status == 'completed'\n        else '\u274c'\n        if result.status == 'error'\n        else '\ud83c\udfc3'\n        if result.status == 'started'\n        else '\u23f3'\n    )\n\n    # Format handler name with bus info\n    handler_display = f'{result.eventbus_name}.{result.handler_name}#{result.handler_id[-4:]}'\n\n    # Format the result line\n    result_line = f'{indent}{connector}{result_icon} {handler_display}'\n\n    # Add timing info\n    if result.started_at:\n        result_line += f' [{format_timestamp(result.started_at)}'\n        if result.completed_at:\n            duration = (result.completed_at - result.started_at).total_seconds()\n            result_line += f' ({duration:.3f}s)'\n        result_line += ']'\n\n    # Add result value or error\n    if result.status == 'error' and result.error:\n        result_line += f' \u274c {type(result.error).__name__}: {str(result.error)}'\n    elif result.status == 'completed':\n        result_line += f' \u2192 {format_result_value(result.result)}'\n\n    print(result_line)\n\n    # Calculate the new indent for child events\n    extension = '    ' if is_last else '\u2502   '\n    new_indent = indent + extension\n\n    # Print child events dispatched by this handler\n    if result.event_children:\n        for i, child in enumerate(result.event_children):\n            is_last_child = i == len(result.event_children) - 1\n            log_event_tree(child, new_indent, is_last_child, child_events_by_parent)", "variables": ["duration-><Call owner_token=UNKNOWN_VAR token=total_seconds>"]}, "node_768a3c6d": {"uid": "node_768a3c6d", "label": "0: (global)()", "name": "models::(global)", "parent": "models", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["annotations->UNKNOWN_MODULE", "asyncio->UNKNOWN_MODULE", "inspect->UNKNOWN_MODULE", "logging-><Group token=logging type=File>", "os->UNKNOWN_MODULE", "Awaitable->UNKNOWN_MODULE", "Callable->UNKNOWN_MODULE", "Generator->UNKNOWN_MODULE", "UTC->UNKNOWN_MODULE", "datetime->UNKNOWN_MODULE", "TYPE_CHECKING->UNKNOWN_MODULE", "Annotated->UNKNOWN_MODULE", "Any->UNKNOWN_MODULE", "Literal->UNKNOWN_MODULE", "Protocol->UNKNOWN_MODULE", "Self->UNKNOWN_MODULE", "TypeAlias->UNKNOWN_MODULE", "TypeVar->UNKNOWN_MODULE", "runtime_checkable->UNKNOWN_MODULE", "UUID->UNKNOWN_MODULE", "AfterValidator->UNKNOWN_MODULE", "BaseModel->UNKNOWN_MODULE", "ConfigDict->UNKNOWN_MODULE", "Field->UNKNOWN_MODULE", "PrivateAttr->UNKNOWN_MODULE", "model_validator->UNKNOWN_MODULE", "uuid7str->UNKNOWN_MODULE", "EventBus->UNKNOWN_MODULE", "logger-><Call owner_token=logging token=getLogger>", "BUBUS_LOG_LEVEL-><Call owner_token=os token=getenv>", "LIBRARY_VERSION-><Call owner_token=os token=getenv>", "T_Event-><Call owner_token=None token=TypeVar>", "T_EventInvariant-><Call owner_token=None token=TypeVar>", "pydantic_builtin_attrs-><Call owner_token=None token=dir>"]}, "node_96a812c6": {"uid": "node_96a812c6", "label": "223: __await__()", "name": "models::BaseEvent.__await__", "parent": "BaseEvent", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["EventBus->UNKNOWN_MODULE", "holds_global_lock->UNKNOWN_MODULE", "inside_handler_context->UNKNOWN_MODULE", "event-><Call owner_token=bus token=get_nowait>", "self-><Group token=BaseEvent type=Class>"]}, "node_fc8b7d19": {"uid": "node_fc8b7d19", "label": "488: event_are_all_children_complete()", "name": "models::BaseEvent.event_are_all_children_complete", "parent": "BaseEvent", "is_leaf": false, "is_trunk": false, "source_code": null, "variables": ["self-><Group token=BaseEvent type=Class>"]}, "node_5a258cb0": {"uid": "node_5a258cb0", "label": "503: event_log_tree()", "name": "models::BaseEvent.event_log_tree", "parent": "BaseEvent", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["log_event_tree->UNKNOWN_MODULE", "self-><Group token=BaseEvent type=Class>"]}, "node_f05f8f75": {"uid": "node_f05f8f75", "label": "464: event_mark_complete_if_all_handlers_completed()", "name": "models::BaseEvent.event_mark_complete_if_all_handlers_completed", "parent": "BaseEvent", "is_leaf": false, "is_trunk": false, "source_code": null, "variables": ["all_handlers_done-><Call owner_token=None token=all>", "self-><Group token=BaseEvent type=Class>"]}, "node_4f2ab8db": {"uid": "node_4f2ab8db", "label": "349: event_result()", "name": "models::BaseEvent.event_result", "parent": "BaseEvent", "is_leaf": false, "is_trunk": false, "source_code": null, "variables": ["results-><Call owner_token=None token=list>", "self-><Group token=BaseEvent type=Class>"]}, "node_7fe487d2": {"uid": "node_7fe487d2", "label": "427: event_result_update()", "name": "models::BaseEvent.event_result_update", "parent": "BaseEvent", "is_leaf": false, "is_trunk": false, "source_code": null, "variables": ["EventBus->UNKNOWN_MODULE", "self-><Group token=BaseEvent type=Class>"]}, "node_0ed329e3": {"uid": "node_0ed329e3", "label": "355: event_results_by_handler_id()", "name": "models::BaseEvent.event_results_by_handler_id", "parent": "BaseEvent", "is_leaf": true, "is_trunk": false, "source_code": null, "variables": ["self-><Group token=BaseEvent type=Class>"]}, "node_99cd6779": {"uid": "node_99cd6779", "label": "379: event_results_flat_dict()", "name": "models::BaseEvent.event_results_flat_dict", "parent": "BaseEvent", "is_leaf": false, "is_trunk": false, "source_code": null, "variables": ["self-><Group token=BaseEvent type=Class>"]}, "node_1a0a2a24": {"uid": "node_1a0a2a24", "label": "403: event_results_flat_list()", "name": "models::BaseEvent.event_results_flat_list", "parent": "BaseEvent", "is_leaf": true, "is_trunk": false, "source_code": null, "variables": ["self-><Group token=BaseEvent type=Class>"]}, "node_fc7c5b80": {"uid": "node_fc7c5b80", "label": "371: event_results_list()", "name": "models::BaseEvent.event_results_list", "parent": "BaseEvent", "is_leaf": true, "is_trunk": false, "source_code": null, "variables": ["self-><Group token=BaseEvent type=Class>"]}, "node_cef0fd15": {"uid": "node_cef0fd15", "label": "648: log_tree()", "name": "models::EventResult.log_tree", "parent": "EventResult", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["log_eventresult_tree->UNKNOWN_MODULE", "self-><Group token=EventResult type=Class>"]}, "node_3f457f31": {"uid": "node_3f457f31", "label": "625: update()", "name": "models::EventResult.update", "parent": "EventResult", "is_leaf": true, "is_trunk": false, "source_code": null, "variables": ["self-><Group token=EventResult type=Class>"]}, "node_534cb428": {"uid": "node_534cb428", "label": "534: attr_name_allowed()", "name": "models::attr_name_allowed", "parent": "models", "is_leaf": true, "is_trunk": false, "source_code": "def attr_name_allowed(key: str):\n    return key in pydantic_builtin_attrs or key in event_builtin_attrs or key.startswith('_')", "variables": []}, "node_25ce7859": {"uid": "node_25ce7859", "label": "154: get_handler_id()", "name": "models::get_handler_id", "parent": "models", "is_leaf": true, "is_trunk": false, "source_code": "def get_handler_id(handler: EventHandler, eventbus: EventBus | None = None) -> str:\n    \"\"\"Generate a unique handler ID based on the bus and handler instance.\"\"\"\n    if eventbus is None:\n        return str(id(handler))\n    return f'{id(eventbus)}.{id(handler)}'", "variables": []}, "node_4b82fa38": {"uid": "node_4b82fa38", "label": "144: get_handler_name()", "name": "models::get_handler_name", "parent": "models", "is_leaf": true, "is_trunk": false, "source_code": "def get_handler_name(handler: ContravariantEventHandler[T_Event]) -> str:\n    assert hasattr(handler, '__name__'), f'Handler {handler} has no __name__ attribute!'\n    if inspect.ismethod(handler):\n        return f'{handler.__self__}.{handler.__name__}'\n    elif callable(handler):\n        return f'{handler.__module__}.{handler.__name__}'  # type: ignore\n    else:\n        raise ValueError(f'Invalid handler: {handler} {type(handler)}, expected a function, coroutine, or method')", "variables": []}, "node_5036f8b9": {"uid": "node_5036f8b9", "label": "77: get()", "name": "service::CleanShutdownQueue.get", "parent": "CleanShutdownQueue", "is_leaf": false, "is_trunk": false, "source_code": null, "variables": ["self-><Group token=CleanShutdownQueue type=Class>"]}, "node_401c2577": {"uid": "node_401c2577", "label": "127: get_nowait()", "name": "service::CleanShutdownQueue.get_nowait", "parent": "CleanShutdownQueue", "is_leaf": false, "is_trunk": false, "source_code": null, "variables": ["self-><Group token=CleanShutdownQueue type=Class>"]}, "node_6bf01a78": {"uid": "node_6bf01a78", "label": "100: put()", "name": "service::CleanShutdownQueue.put", "parent": "CleanShutdownQueue", "is_leaf": false, "is_trunk": false, "source_code": null, "variables": ["self-><Group token=CleanShutdownQueue type=Class>"]}, "node_40cc180e": {"uid": "node_40cc180e", "label": "121: put_nowait()", "name": "service::CleanShutdownQueue.put_nowait", "parent": "CleanShutdownQueue", "is_leaf": false, "is_trunk": false, "source_code": null, "variables": ["self-><Group token=CleanShutdownQueue type=Class>"]}, "node_c2b32b93": {"uid": "node_c2b32b93", "label": "60: shutdown()", "name": "service::CleanShutdownQueue.shutdown", "parent": "CleanShutdownQueue", "is_leaf": true, "is_trunk": false, "source_code": null, "variables": ["getter-><Call owner_token=self token=popleft>", "putter-><Call owner_token=self token=popleft>", "self-><Group token=CleanShutdownQueue type=Class>"]}, "node_c047ad91": {"uid": "node_c047ad91", "label": "328: __del__()", "name": "service::EventBus.__del__", "parent": "EventBus", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["self-><Group token=EventBus type=Class>"]}, "node_a22c83f0": {"uid": "node_a22c83f0", "label": "257: __init__()", "name": "service::EventBus.__init__", "parent": "EventBus", "is_leaf": true, "is_trunk": false, "source_code": null, "variables": ["self-><Group token=EventBus type=Class>"]}, "node_3af19848": {"uid": "node_3af19848", "label": "1244: _check_total_memory_usage()", "name": "service::EventBus._check_total_memory_usage", "parent": "EventBus", "is_leaf": true, "is_trunk": false, "source_code": null, "variables": ["sys->UNKNOWN_MODULE", "self-><Group token=EventBus type=Class>"]}, "node_684c62e9": {"uid": "node_684c62e9", "label": "1130: _default_log_handler()", "name": "service::EventBus._default_log_handler", "parent": "EventBus", "is_leaf": true, "is_trunk": false, "source_code": null, "variables": ["self-><Group token=EventBus type=Class>"]}, "node_121fc3f6": {"uid": "node_121fc3f6", "label": "1137: _default_wal_handler()", "name": "service::EventBus._default_wal_handler", "parent": "EventBus", "is_leaf": true, "is_trunk": false, "source_code": null, "variables": ["event_json-><Call owner_token=event token=model_dump_json>", "self-><Group token=EventBus type=Class>"]}, "node_6816f88b": {"uid": "node_6816f88b", "label": "894: _execute_handlers()", "name": "service::EventBus._execute_handlers", "parent": "EventBus", "is_leaf": false, "is_trunk": false, "source_code": null, "variables": ["context-><Call owner_token=contextvars token=copy_context>", "task-><Call owner_token=asyncio token=create_task>", "self-><Group token=EventBus type=Class>"]}, "node_cc1a3b6e": {"uid": "node_cc1a3b6e", "label": "935: _execute_sync_or_async_handler()", "name": "service::EventBus._execute_sync_or_async_handler", "parent": "EventBus", "is_leaf": false, "is_trunk": false, "source_code": null, "variables": ["handler_id-><Call owner_token=None token=get_handler_id>", "event_result-><Call owner_token=event token=event_result_update>", "token-><Call owner_token=_current_event_context token=set>", "handler_token-><Call owner_token=inside_handler_context token=set>", "monitor_task-><Call owner_token=asyncio token=create_task>", "self-><Group token=EventBus type=Class>"]}, "node_c62d4c60": {"uid": "node_c62d4c60", "label": "871: _get_applicable_handlers()", "name": "service::EventBus._get_applicable_handlers", "parent": "EventBus", "is_leaf": false, "is_trunk": false, "source_code": null, "variables": ["handler_id-><Call owner_token=None token=get_handler_id>", "self-><Group token=EventBus type=Class>"]}, "node_7ba1912f": {"uid": "node_7ba1912f", "label": "790: _get_next_event()", "name": "service::EventBus._get_next_event", "parent": "EventBus", "is_leaf": false, "is_trunk": false, "source_code": null, "variables": ["get_next_queued_event-><Call owner_token=asyncio token=create_task>", "self-><Group token=EventBus type=Class>"]}, "node_225cd398": {"uid": "node_225cd398", "label": "1095: _handler_dispatched_ancestor()", "name": "service::EventBus._handler_dispatched_ancestor", "parent": "EventBus", "is_leaf": false, "is_trunk": false, "source_code": null, "variables": ["visited-><Call owner_token=None token=set>", "self-><Group token=EventBus type=Class>"]}, "node_4ec4defe": {"uid": "node_4ec4defe", "label": "763: _run_loop()", "name": "service::EventBus._run_loop", "parent": "EventBus", "is_leaf": false, "is_trunk": false, "source_code": null, "variables": ["self-><Group token=EventBus type=Class>"]}, "node_ca737f95": {"uid": "node_ca737f95", "label": "820: _run_loop_step()", "name": "service::EventBus._run_loop_step", "parent": "EventBus", "is_leaf": false, "is_trunk": false, "source_code": null, "variables": ["self-><Group token=EventBus type=Class>"]}, "node_c347e76a": {"uid": "node_c347e76a", "label": "616: _start()", "name": "service::EventBus._start", "parent": "EventBus", "is_leaf": false, "is_trunk": false, "source_code": null, "variables": ["loop-><Call owner_token=asyncio token=get_running_loop>", "self-><Group token=EventBus type=Class>"]}, "node_f675afd0": {"uid": "node_f675afd0", "label": "1039: _would_create_loop()", "name": "service::EventBus._would_create_loop", "parent": "EventBus", "is_leaf": false, "is_trunk": false, "source_code": null, "variables": ["handler_id-><Call owner_token=None token=get_handler_id>", "recursion_depth-><Call owner_token=self token=_handler_dispatched_ancestor>", "self-><Group token=EventBus type=Class>"]}, "node_2419c883": {"uid": "node_2419c883", "label": "1176: cleanup_event_history()", "name": "service::EventBus.cleanup_event_history", "parent": "EventBus", "is_leaf": true, "is_trunk": false, "source_code": null, "variables": ["total_events-><Call owner_token=None token=len>", "remove_from_completed-><Call owner_token=None token=min>", "remove_from_started-><Call owner_token=None token=min>", "self-><Group token=EventBus type=Class>"]}, "node_987455fb": {"uid": "node_987455fb", "label": "464: dispatch()", "name": "service::EventBus.dispatch", "parent": "EventBus", "is_leaf": false, "is_trunk": false, "source_code": null, "variables": ["current_event-><Call owner_token=_current_event_context token=get>", "pending_in_history-><Call owner_token=None token=sum>", "self-><Group token=EventBus type=Class>"]}, "node_878e294b": {"uid": "node_878e294b", "label": "559: expect()", "name": "service::EventBus.expect", "parent": "EventBus", "is_leaf": false, "is_trunk": false, "source_code": null, "variables": ["current_frame-><Call owner_token=inspect token=currentframe>", "self-><Group token=EventBus type=Class>"]}, "node_301cc7e4": {"uid": "node_301cc7e4", "label": "1238: log_tree()", "name": "service::EventBus.log_tree", "parent": "EventBus", "is_leaf": false, "is_trunk": false, "source_code": null, "variables": ["log_eventbus_tree->UNKNOWN_MODULE", "self-><Group token=EventBus type=Class>"]}, "node_5b816109": {"uid": "node_5b816109", "label": "402: on()", "name": "service::EventBus.on", "parent": "EventBus", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["event_key-><Call owner_token=None token=str>", "new_handler_name-><Call owner_token=None token=get_handler_name>", "self-><Group token=EventBus type=Class>"]}, "node_5e66fd0d": {"uid": "node_5e66fd0d", "label": "375: on()", "name": "service::EventBus.on", "parent": "EventBus", "is_leaf": true, "is_trunk": false, "source_code": null, "variables": ["self-><Group token=EventBus type=Class>"]}, "node_c971e5ae": {"uid": "node_c971e5ae", "label": "853: process_event()", "name": "service::EventBus.process_event", "parent": "EventBus", "is_leaf": false, "is_trunk": false, "source_code": null, "variables": ["applicable_handlers-><Call owner_token=self token=_get_applicable_handlers>", "self-><Group token=EventBus type=Class>"]}, "node_2ed9b2de": {"uid": "node_2ed9b2de", "label": "674: stop()", "name": "service::EventBus.stop", "parent": "EventBus", "is_leaf": false, "is_trunk": false, "source_code": null, "variables": ["self-><Group token=EventBus type=Class>"]}, "node_5bcc7357": {"uid": "node_5bcc7357", "label": "740: wait_until_idle()", "name": "service::EventBus.wait_until_idle", "parent": "EventBus", "is_leaf": false, "is_trunk": false, "source_code": null, "variables": ["join_task-><Call owner_token=asyncio token=create_task>", "idle_task-><Call owner_token=asyncio token=create_task>", "self-><Group token=EventBus type=Class>"]}, "node_a683e24a": {"uid": "node_a683e24a", "label": "159: __aenter__()", "name": "service::ReentrantLock.__aenter__", "parent": "ReentrantLock", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["self-><Group token=ReentrantLock type=Class>"]}, "node_64be10f9": {"uid": "node_64be10f9", "label": "171: __aexit__()", "name": "service::ReentrantLock.__aexit__", "parent": "ReentrantLock", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["self-><Group token=ReentrantLock type=Class>"]}, "node_0a49c07d": {"uid": "node_0a49c07d", "label": "145: __init__()", "name": "service::ReentrantLock.__init__", "parent": "ReentrantLock", "is_leaf": true, "is_trunk": false, "source_code": null, "variables": ["self-><Group token=ReentrantLock type=Class>"]}, "node_5f08574f": {"uid": "node_5f08574f", "label": "150: _get_semaphore()", "name": "service::ReentrantLock._get_semaphore", "parent": "ReentrantLock", "is_leaf": true, "is_trunk": false, "source_code": null, "variables": ["current_loop-><Call owner_token=asyncio token=get_running_loop>", "self-><Group token=ReentrantLock type=Class>"]}, "node_b6931fc1": {"uid": "node_b6931fc1", "label": "182: locked()", "name": "service::ReentrantLock.locked", "parent": "ReentrantLock", "is_leaf": false, "is_trunk": false, "source_code": null, "variables": ["current_loop-><Call owner_token=asyncio token=get_running_loop>", "self-><Group token=ReentrantLock type=Class>"]}, "node_37ba54f4": {"uid": "node_37ba54f4", "label": "199: _get_global_lock()", "name": "service::_get_global_lock", "parent": "service", "is_leaf": false, "is_trunk": false, "source_code": "def _get_global_lock() -> ReentrantLock:\n    \"\"\"Get or create the global EventBus lock.\"\"\"\n    global _global_eventbus_lock\n    if _global_eventbus_lock is None:\n        _global_eventbus_lock = ReentrantLock()\n    return _global_eventbus_lock", "variables": ["_global_eventbus_lock-><Group token=ReentrantLock type=Class>"]}, "node_63ae605d": {"uid": "node_63ae605d", "label": "207: _log_pretty_path()", "name": "service::_log_pretty_path", "parent": "service", "is_leaf": true, "is_trunk": false, "source_code": "def _log_pretty_path(path: Path | str | None) -> str:\n    \"\"\"Pretty-print a path, shorten home dir to ~ and cwd to .\"\"\"\n\n    if not path or not str(path).strip():\n        return ''  # always falsy in -> falsy out so it can be used in ternaries\n\n    # dont print anything thats not a path\n    if not isinstance(path, (str, Path)):  # type: ignore\n        # no other types are safe to just str(path) and log to terminal unless we know what they are\n        # e.g. what if we get storage_date=dict | Path and the dict version could contain real cookies\n        return f'<{type(path).__name__}>'\n\n    # replace home dir and cwd with ~ and .\n    pretty_path = str(path).replace(str(Path.home()), '~').replace(str(Path.cwd().resolve()), '.')\n\n    # wrap in quotes if it contains spaces\n    if pretty_path.strip() and ' ' in pretty_path:\n        pretty_path = f'\"{pretty_path}\"'\n\n    return pretty_path", "variables": ["pretty_path-><Call owner_token=UNKNOWN_VAR token=replace>"]}, "node_535fd480": {"uid": "node_535fd480", "label": "12: get_memory_usage_mb()", "name": "test_20k_events::get_memory_usage_mb", "parent": "test_20k_events", "is_leaf": true, "is_trunk": false, "source_code": "def get_memory_usage_mb():\n    \"\"\"Get current process memory usage in MB\"\"\"\n    process = psutil.Process(os.getpid())\n    return process.memory_info().rss / 1024 / 1024", "variables": ["process-><Call owner_token=psutil token=Process>"]}, "node_c49aad0e": {"uid": "node_c49aad0e", "label": "19: test_20k_events_with_memory_control()", "name": "test_20k_events::test_20k_events_with_memory_control", "parent": "test_20k_events", "is_leaf": false, "is_trunk": true, "source_code": "async def test_20k_events_with_memory_control():\n    \"\"\"Test processing 20k events with no memory leaks\"\"\"\n\n    # Record initial memory\n    gc.collect()\n    initial_memory = get_memory_usage_mb()\n    print(f'\\nInitial memory: {initial_memory:.1f} MB')\n\n    # Create EventBus with proper limits (now default)\n    bus = EventBus(name='ManyEvents')\n\n    print('EventBus settings:')\n    print(f'  max_history_size: {bus.max_history_size}')\n    print(f'  queue maxsize: {bus.event_queue.maxsize if bus.event_queue else \"not created\"}')\n    print('Starting event dispatch...')\n\n    processed_count = 0\n\n    async def handler(event: BaseEvent):\n        nonlocal processed_count\n        processed_count += 1\n\n    bus.on('TestEvent', handler)\n\n    total_events = 20_000  # Reduced for faster tests\n\n    start_time = time.time()\n    memory_samples: list[float] = []\n    max_memory = initial_memory\n\n    # Dispatch all events as fast as possible\n    dispatched = 0\n    pending_events: list[BaseEvent] = []\n\n    while dispatched < total_events:\n        try:\n            event = bus.dispatch(BaseEvent(event_type='TestEvent'))\n            pending_events.append(event)\n            dispatched += 1\n            if dispatched <= 5:\n                print(f'Dispatched event {dispatched}')\n        except RuntimeError as e:\n            if 'EventBus at capacity' in str(e):\n                # Queue is full, complete the oldest pending events to make room\n                # Complete first 10 events to free up space\n                if pending_events:\n                    to_complete = pending_events[:10]\n                    await asyncio.gather(*to_complete)\n                    pending_events = pending_events[10:]\n            else:\n                raise\n\n        # Sample memory every 10k events\n        if dispatched % 10_000 == 0 and dispatched > 0:\n            gc.collect()\n            current_memory = get_memory_usage_mb()\n            memory_samples.append(current_memory)\n            max_memory = max(max_memory, current_memory)\n            elapsed = time.time() - start_time\n            rate = dispatched / elapsed\n            print(\n                f'Progress: {dispatched:,} events, '\n                f'Memory: {current_memory:.1f} MB (+{current_memory - initial_memory:.1f} MB), '\n                f'History: {len(bus.event_history)}, '\n                f'Rate: {rate:.0f} events/sec'\n            )\n\n    # Wait for all remaining events to complete\n    if pending_events:\n        await asyncio.gather(*pending_events)\n\n    # Final wait\n    await bus.wait_until_idle()\n\n    duration = time.time() - start_time\n\n    # Final memory check\n    gc.collect()\n    final_memory = get_memory_usage_mb()\n    memory_growth = final_memory - initial_memory\n    peak_growth = max_memory - initial_memory\n\n    print('\\nFinal Results:')\n    print(f'Processed: {processed_count:,} events')\n    print(f'Duration: {duration:.2f} seconds')\n    print(f'Rate: {processed_count / duration:,.0f} events/sec')\n    print(f'Initial memory: {initial_memory:.1f} MB')\n    print(f'Peak memory: {max_memory:.1f} MB (+{peak_growth:.1f} MB)')\n    print(f'Final memory: {final_memory:.1f} MB (+{memory_growth:.1f} MB)')\n    print(f'Event history size: {len(bus.event_history)} (capped at {bus.max_history_size})')\n\n    # Verify results\n    assert processed_count == total_events, f'Only processed {processed_count} of {total_events}'\n    assert duration < 30, f'Took {duration:.2f}s, should be < 30s'  # Reasonable time for 20k events\n\n    # Check memory usage stayed reasonable\n    assert peak_growth < 100, f'Memory grew by {peak_growth:.1f} MB at peak, indicates memory leak'\n\n    # Check event history is properly limited\n    assert bus.max_history_size is not None\n    assert len(bus.event_history) <= bus.max_history_size, (\n        f'Event history has {len(bus.event_history)} events, should be <= {bus.max_history_size}'\n    )", "variables": ["initial_memory-><Call owner_token=None token=get_memory_usage_mb>", "bus-><Group token=EventBus type=Class>", "start_time-><Call owner_token=time token=time>", "event-><Call owner_token=bus token=dispatch>", "current_memory-><Call owner_token=None token=get_memory_usage_mb>", "max_memory-><Call owner_token=None token=max>", "final_memory-><Call owner_token=None token=get_memory_usage_mb>"]}, "node_61a62a43": {"uid": "node_61a62a43", "label": "163: test_cleanup_prioritizes_pending()", "name": "test_20k_events::test_cleanup_prioritizes_pending", "parent": "test_20k_events", "is_leaf": false, "is_trunk": true, "source_code": "async def test_cleanup_prioritizes_pending():\n    \"\"\"Test that cleanup keeps pending events and removes completed ones\"\"\"\n    bus = EventBus(name='CleanupTest', max_history_size=10)\n\n    try:\n        # Process some events to completion\n        completed_events: list[BaseEvent] = []\n        for _ in range(5):\n            event = bus.dispatch(BaseEvent(event_type='QuickEvent'))\n            completed_events.append(event)\n\n        await asyncio.gather(*completed_events)\n\n        # Add pending events with slow handler (reduced sleep time)\n        async def slow_handler(event: BaseEvent) -> None:\n            if event.event_type == 'SlowEvent':\n                await asyncio.sleep(0.5)  # Reduced from 10s to 0.5s\n\n        bus.on('*', slow_handler)\n\n        pending_events: list[BaseEvent] = []\n        for _ in range(10):\n            event = bus.dispatch(BaseEvent(event_type='SlowEvent'))\n            pending_events.append(event)\n\n        # Give them time to start\n        await asyncio.sleep(0.1)\n\n        # Check history - should prioritize keeping pending events\n        history_types: dict[str, int] = {}\n        for event in bus.event_history.values():\n            status = event.event_status\n            history_types[status] = history_types.get(status, 0) + 1\n\n        print('\\nHistory after cleanup:')\n        print(f'  Total: {len(bus.event_history)} (max: {bus.max_history_size})')\n        print(f'  By status: {history_types}')\n\n        # Should have removed completed events to make room for pending\n        assert bus.max_history_size is not None\n        assert len(bus.event_history) <= bus.max_history_size\n        assert history_types.get('pending', 0) + history_types.get('started', 0) >= 5\n\n    finally:\n        # Properly stop the bus to clean up pending tasks\n        await bus.stop(timeout=0, clear=True)", "variables": ["bus-><Group token=EventBus type=Class>", "event-><Call owner_token=bus token=dispatch>", "event-><Call owner_token=bus token=dispatch>"]}, "node_29f46801": {"uid": "node_29f46801", "label": "125: test_hard_limit_enforcement()", "name": "test_20k_events::test_hard_limit_enforcement", "parent": "test_20k_events", "is_leaf": false, "is_trunk": true, "source_code": "async def test_hard_limit_enforcement():\n    \"\"\"Test that hard limit of 100 pending events is enforced\"\"\"\n    bus = EventBus(name='HardLimitTest')\n\n    try:\n        # Create a slow handler to keep events pending\n        async def slow_handler(event: BaseEvent):\n            await asyncio.sleep(0.5)  # Reduced from 10s to 0.5s\n\n        bus.on('TestEvent', slow_handler)\n\n        # Try to dispatch more than 100 events\n        events_dispatched = 0\n        errors = 0\n\n        for _ in range(150):\n            try:\n                bus.dispatch(BaseEvent(event_type='TestEvent'))\n                events_dispatched += 1\n            except RuntimeError as e:\n                if 'EventBus at capacity' in str(e):\n                    errors += 1\n                else:\n                    raise\n\n        print(f'\\nDispatched {events_dispatched} events')\n        print(f'Hit capacity error {errors} times')\n\n        # Should hit the limit\n        assert events_dispatched <= 100\n        assert errors > 0\n\n    finally:\n        # Properly stop the bus to clean up pending tasks\n        await bus.stop(timeout=0, clear=True)", "variables": ["bus-><Group token=EventBus type=Class>"]}, "node_de2f7682": {"uid": "node_de2f7682", "label": "41: test_event_started_at_after_processing()", "name": "test_attribute_error_fix::test_event_started_at_after_processing", "parent": "test_attribute_error_fix", "is_leaf": false, "is_trunk": true, "source_code": "async def test_event_started_at_after_processing():\n    \"\"\"Test that event_started_at works correctly after event processing\"\"\"\n    bus = EventBus(name='TestBus')\n\n    # Handler that does nothing\n    async def test_handler(event: SampleEvent) -> str:\n        await asyncio.sleep(0.01)\n        return 'done'\n\n    bus.on('SampleEvent', test_handler)\n\n    # Dispatch event\n    event = await bus.dispatch(SampleEvent(data='processing_test'))\n\n    # Check timestamps - should not raise AttributeError\n    assert event.event_started_at is not None\n    assert event.event_completed_at is not None\n    assert isinstance(event.event_started_at, datetime)\n    assert isinstance(event.event_completed_at, datetime)\n\n    await bus.stop()", "variables": ["bus-><Group token=EventBus type=Class>"]}, "node_85d0bc5c": {"uid": "node_85d0bc5c", "label": "84: test_event_with_manually_set_processed_at()", "name": "test_attribute_error_fix::test_event_with_manually_set_processed_at", "parent": "test_attribute_error_fix", "is_leaf": false, "is_trunk": true, "source_code": "def test_event_with_manually_set_processed_at():\n    \"\"\"Test events where event_processed_at is manually set (like in test_log_history_tree.py)\"\"\"\n    event = SampleEvent(data='manual')\n\n    # Initialize the completion signal\n    _ = event.event_completed_signal\n\n    # Manually set the processed timestamp (as done in tests)\n    if hasattr(event, 'event_processed_at'):\n        event.event_processed_at = datetime.now(UTC)\n\n    # Should not raise AttributeError\n    assert event.event_started_at is not None  # Should use event_processed_at\n    # Note: Since we set event_processed_at and there are no handlers, event_completed_at will also return event_processed_at\n    assert event.event_completed_at is not None\n\n    # Add a handler result to make it incomplete\n    event.event_result_update(handler=lambda e: None, status='started')\n    assert event.event_completed_at is None  # Now it's not complete\n\n    # Complete the handler\n    list(event.event_results.values())[0].update(status='completed', result='done')\n    event.event_mark_complete_if_all_handlers_completed()\n    assert event.event_completed_at is not None", "variables": ["event-><Group token=SampleEvent type=Class>"]}, "node_7a18352b": {"uid": "node_7a18352b", "label": "64: test_event_without_handlers()", "name": "test_attribute_error_fix::test_event_without_handlers", "parent": "test_attribute_error_fix", "is_leaf": false, "is_trunk": true, "source_code": "async def test_event_without_handlers():\n    \"\"\"Test that events without handlers still work with timestamp properties\"\"\"\n    event = SampleEvent(data='no_handlers')\n\n    # Should not raise AttributeError when accessing these properties\n    assert event.event_started_at is None  # No handlers started\n    assert event.event_completed_at is None  # Not complete yet\n\n    # Initialize the completion signal (normally done when dispatched)\n    _ = event.event_completed_signal\n\n    # Mark as processed manually (simulating what happens in event_mark_complete_if_all_handlers_completed)\n    event.event_mark_complete_if_all_handlers_completed()\n\n    # After marking complete, it should be set\n    # When no handlers but event is processed, event_started_at returns event_processed_at\n    assert event.event_started_at is not None  # Uses event_processed_at\n    assert event.event_completed_at is not None", "variables": ["event-><Group token=SampleEvent type=Class>"]}, "node_9076ef0b": {"uid": "node_9076ef0b", "label": "0: (global)()", "name": "test_comprehensive_patterns::(global)", "parent": "test_comprehensive_patterns", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["asyncio->UNKNOWN_MODULE", "BaseEvent->UNKNOWN_MODULE", "EventBus->UNKNOWN_MODULE"]}, "node_8df69732": {"uid": "node_8df69732", "label": "234: main()", "name": "test_comprehensive_patterns::main", "parent": "test_comprehensive_patterns", "is_leaf": false, "is_trunk": false, "source_code": "async def main():\n    \"\"\"Run all tests.\"\"\"\n    await test_comprehensive_patterns()\n    await test_race_condition_stress()", "variables": []}, "node_76ec5898": {"uid": "node_76ec5898", "label": "24: test_comprehensive_patterns()", "name": "test_comprehensive_patterns::test_comprehensive_patterns", "parent": "test_comprehensive_patterns", "is_leaf": false, "is_trunk": false, "source_code": "async def test_comprehensive_patterns():\n    \"\"\"Test all event patterns work correctly without race conditions.\"\"\"\n    print('\\n=== Test Comprehensive Patterns ===')\n\n    bus1 = EventBus(name='bus1')\n    bus2 = EventBus(name='bus2')  # Fixed typo from 'bus1' to 'bus2'\n\n    results: list[tuple[int, str]] = []\n    execution_counter = {'count': 0}  # Use a dict to track execution order\n\n    def child_bus2_event_handler(event: BaseEvent):\n        \"\"\"This gets triggered when the event is forwarded to the second bus.\"\"\"\n        execution_counter['count'] += 1\n        seq = execution_counter['count']\n        event_type_short = event.__class__.__name__.replace('Event', '')\n        print(f'[{seq}] child_bus2_event_handler: processing {event.__class__.__name__} on bus2')\n        results.append((seq, f'bus2_handler_{event_type_short}'))\n        return 'forwarded bus result'\n\n    bus2.on('*', child_bus2_event_handler)  # register a handler on bus2\n    bus1.on('*', bus2.dispatch)  # forward all events from bus1 -> bus2\n\n    async def parent_bus1_handler(event: ParentEvent):\n        # Only process the parent ParentEvent\n\n        execution_counter['count'] += 1\n        seq = execution_counter['count']\n        print(f'\\n[{seq}] parent_bus1_handler: START processing {event}')\n        results.append((seq, 'parent_start'))\n\n        # Pattern 1: Async dispatch - handlers run after parent completes\n        print('\\n1. Testing async dispatch...')\n        child_event_async = bus1.dispatch(QueuedChildEvent())\n        print(f'   child_event_async.event_status = {child_event_async.event_status}')\n        assert child_event_async.event_status != 'completed'\n\n        # Pattern 2: Sync dispatch with await - handlers run immediately\n        print('\\n2. Testing sync dispatch (await)...')\n        child_event_sync = await bus1.dispatch(ImmediateChildEvent())\n        print(f'   child_event_sync.event_status = {child_event_sync.event_status}')\n        assert child_event_sync.event_status == 'completed'\n\n        # Check that forwarded handler result is available\n        print('\\n3. Checking forwarded handler results...')\n        event_results = await child_event_sync.event_results_list()\n        print(f'   Results: {event_results}')\n        # The forwarding handler (bus.dispatch) returns the event object itself\n        # We need to check if the child event was processed on bus2\n        assert len(event_results) > 0  # At least one handler processed it\n        # The event should have been forwarded to bus2\n        assert 'bus2' in child_event_sync.event_path\n\n        # Check parent-child relationships\n        print('\\n4. Checking parent-child relationships...')\n        print(f'   child_event_async.event_parent_id = {child_event_async.event_parent_id}')\n        print(f'   child_event_sync.event_parent_id = {child_event_sync.event_parent_id}')\n        print(f'   event.event_id = {event.event_id}')\n        assert child_event_async.event_parent_id == event.event_id\n        assert child_event_sync.event_parent_id == event.event_id\n\n        execution_counter['count'] += 1\n        seq = execution_counter['count']\n        print(f'[{seq}] parent_bus1_handler: END')\n        results.append((seq, 'parent_end'))\n        return 'parent_done'\n\n    bus1.on(ParentEvent, parent_bus1_handler)\n\n    # Dispatch parent event and wait for completion\n    print('\\nDispatching parent event...')\n    parent_event = await bus1.dispatch(ParentEvent())\n\n    # Wait for all buses to finish processing\n    await bus1.wait_until_idle()\n    await bus2.wait_until_idle()\n\n    # Verify all child events have correct parent\n    print('\\n5. Verifying all events have correct parent...')\n    all_events = list(bus1.event_history.values())\n    print(f'   Total events in history: {len(all_events)}')\n    for i, event in enumerate(all_events):\n        print(\n            f'   Event {i}: {event.__class__.__name__}, id: {event.event_id[-4:]}, parent_id: {event.event_parent_id[-4:] if event.event_parent_id else \"None\"}'\n        )\n\n    # Child events should have parent's ID\n    child_events = [e for e in all_events if isinstance(e, (ImmediateChildEvent, QueuedChildEvent))]\n    assert all(event.event_parent_id == parent_event.event_id for event in child_events)\n\n    # Sort results by sequence number to see actual execution order\n    sorted_results = sorted(results, key=lambda x: x[0])\n    execution_order = [item[1] for item in sorted_results]\n\n    print('\\nExecution order:')\n    for seq, action in sorted_results:\n        print(f'  [{seq}] {action}')\n\n    # Verify the execution order\n    # The actual order depends on handler registration and event processing\n    print(f'\\nActual execution order: {execution_order}')\n\n    # 1. Parent handler starts\n    assert execution_order[0] == 'parent_start'\n\n    # 2. ImmediateChild is processed immediately (during await)\n    assert 'bus2_handler_ImmediateChild' in execution_order\n\n    # 3. Parent handler should finish (if no error)\n    if 'parent_end' in execution_order:\n        parent_end_idx = execution_order.index('parent_end')\n        assert parent_end_idx > 1\n\n    # 4. Count events: 1 ImmediateChild, 1 QueuedChild, 1 Parent\n    assert execution_order.count('bus2_handler_ImmediateChild') == 1\n    assert execution_order.count('bus2_handler_QueuedChild') == 1\n    assert execution_order.count('bus2_handler_Parent') == 1\n\n    print('\\n\u2705 All comprehensive patterns work correctly!')\n\n    # Print event history tree before stopping buses\n    print('\\nEvent History Trees:')\n    print(f'bus1 has {len(bus1.event_history)} events in history')\n    print(f'bus2 has {len(bus2.event_history)} events in history')\n\n    # Debug: show which events have None parent\n    print('\\nEvents with no parent (roots):')\n    for event in bus1.event_history.values():\n        if event.event_parent_id is None:\n            print(f'  - {event}')\n\n    from bubus.logging import log_eventbus_tree\n\n    log_eventbus_tree(bus1)\n    log_eventbus_tree(bus2)\n\n    await bus1.stop(clear=True)\n    await bus2.stop(clear=True)", "variables": ["bus1-><Group token=EventBus type=Class>", "bus2-><Group token=EventBus type=Class>", "event_type_short-><Call owner_token=event token=replace>", "child_event_async-><Call owner_token=bus1 token=dispatch>", "all_events-><Call owner_token=None token=list>", "sorted_results-><Call owner_token=None token=sorted>", "parent_end_idx-><Call owner_token=execution_order token=index>", "log_eventbus_tree->UNKNOWN_MODULE"]}, "node_ef1fd925": {"uid": "node_ef1fd925", "label": "163: test_race_condition_stress()", "name": "test_comprehensive_patterns::test_race_condition_stress", "parent": "test_comprehensive_patterns", "is_leaf": false, "is_trunk": false, "source_code": "async def test_race_condition_stress():\n    \"\"\"Stress test to ensure no race conditions.\"\"\"\n    print('\\n=== Test Race Condition Stress ===')\n\n    bus1 = EventBus(name='bus1')\n    bus2 = EventBus(name='bus2')\n\n    results: list[str] = []\n\n    async def child_handler(event: BaseEvent):\n        bus_name = event.event_path[-1] if event.event_path else 'unknown'\n        results.append(f'child_{bus_name}')\n        # Add small delay to simulate work\n        await asyncio.sleep(0.001)\n        return f'child_done_{bus_name}'\n\n    async def parent_handler(event: BaseEvent):\n        # Dispatch multiple children in different ways\n        children: list[BaseEvent] = []\n\n        # Async dispatches\n        for _ in range(3):\n            children.append(bus1.dispatch(QueuedChildEvent()))\n\n        # Sync dispatches\n        for _ in range(3):\n            child = await bus1.dispatch(ImmediateChildEvent())\n            assert child.event_status == 'completed'\n            children.append(child)\n\n        # Verify all have correct parent\n        assert all(c.event_parent_id == event.event_id for c in children)\n        return 'parent_done'\n\n    def bad_handler(bad: BaseEvent):\n        pass\n\n    # Setup forwarding\n    bus1.on('*', bus2.dispatch)\n    bus1.on(QueuedChildEvent, child_handler)\n    bus1.on(ImmediateChildEvent, child_handler)\n    bus2.on(QueuedChildEvent, child_handler)\n    bus2.on(ImmediateChildEvent, child_handler)\n    bus1.on(BaseEvent, parent_handler)\n    bus1.on(BaseEvent, bad_handler)\n\n    # Run multiple times to check for race conditions\n    for run in range(5):\n        results.clear()\n\n        await bus1.dispatch(BaseEvent())\n        await bus1.wait_until_idle()\n        await bus2.wait_until_idle()\n\n        # Should have 6 child events processed on each bus\n        assert results.count('child_bus1') == 6, f'Run {run}: Expected 6 child_bus1, got {results.count(\"child_bus1\")}'\n        assert results.count('child_bus2') == 6, f'Run {run}: Expected 6 child_bus2, got {results.count(\"child_bus2\")}'\n\n    print('\u2705 No race conditions detected!')\n\n    # Print event history tree for the last run\n    print('\\nEvent history for the last test run:')\n    from bubus.logging import log_eventbus_tree\n\n    log_eventbus_tree(bus1)\n    log_eventbus_tree(bus2)\n\n    await bus1.stop(clear=True)\n    await bus2.stop(clear=True)", "variables": ["bus1-><Group token=EventBus type=Class>", "bus2-><Group token=EventBus type=Class>", "log_eventbus_tree->UNKNOWN_MODULE"]}, "node_c413ce57": {"uid": "node_c413ce57", "label": "237: test_event_bus_property_child_dispatch()", "name": "test_event_bus_property::test_event_bus_property_child_dispatch", "parent": "test_event_bus_property", "is_leaf": false, "is_trunk": true, "source_code": "async def test_event_bus_property_child_dispatch():\n    \"\"\"Test event_bus property when dispatching child events from handlers\"\"\"\n    bus = EventBus(name='MainBus')\n\n    # Track execution order and bus references\n    execution_order: list[str] = []\n    child_event_ref = None\n    grandchild_event_ref = None\n\n    async def parent_handler(event: MainEvent):\n        execution_order.append('parent_start')\n\n        # Verify we can access event_bus\n        assert event.event_bus == bus\n        assert event.event_bus.name == 'MainBus'\n\n        # Dispatch a child event using event.event_bus\n        nonlocal child_event_ref\n        child_event_ref = event.event_bus.dispatch(ChildEvent(data='from_parent'))\n\n        # The child event should start processing immediately within our handler\n        # (due to the deadlock prevention in BaseEvent.__await__)\n        await child_event_ref\n\n        execution_order.append('parent_end')\n\n    async def child_handler(event: ChildEvent):\n        execution_order.append('child_start')\n\n        # Child should see the same bus\n        assert event.event_bus == bus\n        assert event.event_bus.name == 'MainBus'\n        assert event.data == 'from_parent'\n\n        # Dispatch a grandchild event\n        nonlocal grandchild_event_ref\n        grandchild_event_ref = event.event_bus.dispatch(GrandchildEvent(info='from_child'))\n\n        # Wait for grandchild to complete\n        await grandchild_event_ref\n\n        execution_order.append('child_end')\n\n    async def grandchild_handler(event: GrandchildEvent):\n        execution_order.append('grandchild_start')\n\n        # Grandchild should also see the same bus\n        assert event.event_bus == bus\n        assert event.event_bus.name == 'MainBus'\n        assert event.info == 'from_child'\n\n        execution_order.append('grandchild_end')\n\n    # Register handlers\n    bus.on(MainEvent, parent_handler)\n    bus.on(ChildEvent, child_handler)\n    bus.on(GrandchildEvent, grandchild_handler)\n\n    # Dispatch the parent event\n    parent_event = await bus.dispatch(MainEvent(message='start'))\n\n    # Verify execution order - child events should complete before parent\n    assert execution_order == ['parent_start', 'child_start', 'grandchild_start', 'grandchild_end', 'child_end', 'parent_end']\n\n    # Verify all events completed\n    assert parent_event.event_status == 'completed'\n    assert child_event_ref is not None\n    assert child_event_ref.event_status == 'completed'\n    assert grandchild_event_ref is not None\n    assert grandchild_event_ref.event_status == 'completed'\n\n    # Verify parent-child relationships\n    assert child_event_ref.event_parent_id == parent_event.event_id\n    assert grandchild_event_ref.event_parent_id == child_event_ref.event_id\n\n    await bus.stop()", "variables": ["bus-><Group token=EventBus type=Class>", "child_event_ref-><Call owner_token=event token=dispatch>", "grandchild_event_ref-><Call owner_token=event token=dispatch>"]}, "node_f8e070dc": {"uid": "node_f8e070dc", "label": "315: test_event_bus_property_multi_bus_child_dispatch()", "name": "test_event_bus_property::test_event_bus_property_multi_bus_child_dispatch", "parent": "test_event_bus_property", "is_leaf": false, "is_trunk": true, "source_code": "async def test_event_bus_property_multi_bus_child_dispatch():\n    \"\"\"Test event_bus property when child events are dispatched across multiple buses\"\"\"\n    bus1 = EventBus(name='Bus1')\n    bus2 = EventBus(name='Bus2')\n\n    # Forward all events from bus1 to bus2\n    bus1.on('*', bus2.dispatch)\n\n    child_dispatch_bus = None\n    child_handler_bus = None\n    handlers_complete = asyncio.Event()\n\n    async def parent_handler(event: MainEvent):\n        # This handler runs in bus2 (due to forwarding)\n        assert event.event_bus == bus2\n\n        # Dispatch child using event.event_bus (should dispatch to bus2)\n        nonlocal child_dispatch_bus\n        child_dispatch_bus = event.event_bus\n        await event.event_bus.dispatch(ChildEvent(data='from_bus2_handler'))\n\n    async def child_handler(event: ChildEvent):\n        # Child handler should see bus2 as well\n        nonlocal child_handler_bus\n        child_handler_bus = event.event_bus\n        assert event.data == 'from_bus2_handler'\n        handlers_complete.set()\n\n    # Only register handlers on bus2\n    bus2.on(MainEvent, parent_handler)\n    bus2.on(ChildEvent, child_handler)\n\n    # Dispatch to bus1, which forwards to bus2\n    parent_event = bus1.dispatch(MainEvent(message='start'))\n\n    # Wait for handlers to complete\n    await asyncio.wait_for(handlers_complete.wait(), timeout=5.0)\n\n    # Also await the parent event\n    await parent_event\n\n    # Verify child was dispatched to bus2\n    assert child_dispatch_bus is not None\n    assert child_handler_bus is not None\n    assert id(child_dispatch_bus) == id(bus2)\n    assert id(child_handler_bus) == id(bus2)\n\n    await bus1.stop()\n    await bus2.stop()", "variables": ["bus1-><Group token=EventBus type=Class>", "bus2-><Group token=EventBus type=Class>", "handlers_complete-><Call owner_token=asyncio token=Event>", "parent_event-><Call owner_token=bus1 token=dispatch>"]}, "node_ce80632d": {"uid": "node_ce80632d", "label": "62: test_event_bus_property_multiple_buses()", "name": "test_event_bus_property::test_event_bus_property_multiple_buses", "parent": "test_event_bus_property", "is_leaf": false, "is_trunk": true, "source_code": "async def test_event_bus_property_multiple_buses():\n    \"\"\"Test event_bus property with multiple EventBus instances\"\"\"\n    bus1 = EventBus(name='Bus1')\n    bus2 = EventBus(name='Bus2')\n\n    handler1_called = False\n    handler2_called = False\n\n    async def handler1(event: MainEvent):\n        nonlocal handler1_called\n        handler1_called = True\n        # Inside bus1 handler, event_bus should return bus1\n        assert event.event_bus == bus1\n        assert event.event_bus.name == 'Bus1'\n\n    async def handler2(event: MainEvent):\n        nonlocal handler2_called\n        handler2_called = True\n        # Inside bus2 handler, event_bus should return bus2\n        assert event.event_bus == bus2\n        assert event.event_bus.name == 'Bus2'\n\n    bus1.on(MainEvent, handler1)\n    bus2.on(MainEvent, handler2)\n\n    # Dispatch to bus1\n    await bus1.dispatch(MainEvent(message='bus1'))\n    assert handler1_called\n\n    # Dispatch to bus2\n    await bus2.dispatch(MainEvent(message='bus2'))\n    assert handler2_called\n\n    await bus1.stop()\n    await bus2.stop()", "variables": ["bus1-><Group token=EventBus type=Class>", "bus2-><Group token=EventBus type=Class>"]}, "node_9ca5c1d5": {"uid": "node_9ca5c1d5", "label": "156: test_event_bus_property_nested_handlers()", "name": "test_event_bus_property::test_event_bus_property_nested_handlers", "parent": "test_event_bus_property", "is_leaf": false, "is_trunk": true, "source_code": "async def test_event_bus_property_nested_handlers():\n    \"\"\"Test event_bus property in nested handler scenarios\"\"\"\n    bus = EventBus(name='MainBus')\n\n    inner_bus_name = None\n\n    async def outer_handler(event: MainEvent):\n        # Dispatch a child event from within handler\n        child = ChildEvent()\n\n        async def inner_handler(child_event: ChildEvent):\n            nonlocal inner_bus_name\n            # Both parent and child should see the same bus\n            assert child_event.event_bus == event.event_bus\n            inner_bus_name = child_event.event_bus.name\n\n        bus.on(ChildEvent, inner_handler)\n        await event.event_bus.dispatch(child)\n\n    bus.on(MainEvent, outer_handler)\n\n    await bus.dispatch(MainEvent())\n\n    assert inner_bus_name == 'MainBus'\n\n    await bus.stop()", "variables": ["bus-><Group token=EventBus type=Class>", "child-><Group token=ChildEvent type=Class>"]}, "node_94888df4": {"uid": "node_94888df4", "label": "184: test_event_bus_property_no_active_bus()", "name": "test_event_bus_property::test_event_bus_property_no_active_bus", "parent": "test_event_bus_property", "is_leaf": false, "is_trunk": true, "source_code": "async def test_event_bus_property_no_active_bus():\n    \"\"\"Test event_bus property when EventBus has been garbage collected\"\"\"\n    # This is a tricky edge case - create and destroy a bus\n\n    event = None\n\n    async def create_and_dispatch():\n        nonlocal event\n        bus = EventBus(name='TempBus')\n\n        async def handler(e: MainEvent):\n            # Save the event for later\n            nonlocal event\n            event = e\n\n        bus.on(MainEvent, handler)\n        await bus.dispatch(MainEvent())\n        await bus.stop()\n        # Bus goes out of scope here and may be garbage collected\n\n    await create_and_dispatch()\n\n    # Force garbage collection\n    import gc\n\n    gc.collect()\n\n    # Event exists but bus might be gone\n    assert event is not None\n\n    # Create a new handler context to test\n    new_bus = EventBus(name='NewBus')\n\n    error_raised = False\n\n    async def new_handler(e: MainEvent):\n        nonlocal error_raised\n        assert event is not None\n        try:\n            # The old event doesn't belong to this bus\n            _ = event.event_bus\n        except RuntimeError:\n            error_raised = True\n\n    new_bus.on(MainEvent, new_handler)\n    await new_bus.dispatch(MainEvent())\n\n    # Should have raised an error since the original bus is gone\n    assert error_raised\n\n    await new_bus.stop()", "variables": ["bus-><Group token=EventBus type=Class>", "gc->UNKNOWN_MODULE", "new_bus-><Group token=EventBus type=Class>"]}, "node_e137faf3": {"uid": "node_e137faf3", "label": "137: test_event_bus_property_outside_handler()", "name": "test_event_bus_property::test_event_bus_property_outside_handler", "parent": "test_event_bus_property", "is_leaf": false, "is_trunk": true, "source_code": "async def test_event_bus_property_outside_handler():\n    \"\"\"Test that event_bus property raises error when accessed outside handler\"\"\"\n    bus = EventBus(name='TestBus')\n\n    event = MainEvent()\n\n    # Should raise error when accessed outside handler context\n    with pytest.raises(RuntimeError, match='event_bus property can only be accessed from within an event handler'):\n        _ = event.event_bus\n\n    # Even after dispatching, accessing outside handler should fail\n    dispatched_event = await bus.dispatch(event)\n\n    with pytest.raises(RuntimeError, match='event_bus property can only be accessed from within an event handler'):\n        _ = dispatched_event.event_bus\n\n    await bus.stop()", "variables": ["bus-><Group token=EventBus type=Class>", "event-><Group token=MainEvent type=Class>"]}, "node_71c53dc5": {"uid": "node_71c53dc5", "label": "31: test_event_bus_property_single_bus()", "name": "test_event_bus_property::test_event_bus_property_single_bus", "parent": "test_event_bus_property", "is_leaf": false, "is_trunk": true, "source_code": "async def test_event_bus_property_single_bus():\n    \"\"\"Test event_bus property with a single EventBus instance\"\"\"\n    bus = EventBus(name='TestBus')\n\n    # Track if handler was called\n    handler_called = False\n    dispatched_child = None\n\n    async def handler(event: MainEvent):\n        nonlocal handler_called, dispatched_child\n        handler_called = True\n\n        # Should be able to access event_bus inside handler\n        assert event.event_bus == bus\n        assert event.event_bus.name == 'TestBus'\n\n        # Should be able to dispatch child events using the property\n        dispatched_child = await event.event_bus.dispatch(ChildEvent())\n\n    bus.on(MainEvent, handler)\n\n    # Dispatch event and wait for completion\n    await bus.dispatch(MainEvent())\n\n    assert handler_called\n    assert dispatched_child is not None\n    assert isinstance(dispatched_child, ChildEvent)\n\n    await bus.stop()", "variables": ["bus-><Group token=EventBus type=Class>"]}, "node_ff513596": {"uid": "node_ff513596", "label": "99: test_event_bus_property_with_forwarding()", "name": "test_event_bus_property::test_event_bus_property_with_forwarding", "parent": "test_event_bus_property", "is_leaf": false, "is_trunk": true, "source_code": "async def test_event_bus_property_with_forwarding():\n    \"\"\"Test event_bus property with event forwarding between buses\"\"\"\n    bus1 = EventBus(name='Bus1')\n    bus2 = EventBus(name='Bus2')\n\n    # Forward all events from bus1 to bus2\n    bus1.on('*', bus2.dispatch)\n\n    handler_bus = None\n    handler_complete = asyncio.Event()\n\n    async def handler(event: MainEvent):\n        nonlocal handler_bus\n        # When forwarded, the event_bus should be the bus currently processing\n        handler_bus = event.event_bus\n        handler_complete.set()\n\n    bus2.on(MainEvent, handler)\n\n    # Dispatch to bus1, which forwards to bus2\n    event = bus1.dispatch(MainEvent())\n\n    # Wait for handler to complete\n    await handler_complete.wait()\n\n    # The handler in bus2 should see bus2 as the event_bus\n    assert handler_bus is not None\n    assert handler_bus.name == 'Bus2'\n    # Verify it's the same bus instance (they should be the same object)\n    assert handler_bus is bus2\n\n    # Also wait for the event to fully complete\n    await event\n\n    await bus1.stop()\n    await bus2.stop()", "variables": ["bus1-><Group token=EventBus type=Class>", "bus2-><Group token=EventBus type=Class>", "handler_complete-><Call owner_token=asyncio token=Event>", "event-><Call owner_token=bus1 token=dispatch>"]}, "node_fe2341cc": {"uid": "node_fe2341cc", "label": "60: __init__()", "name": "test_eventbus::MockAgent.__init__", "parent": "MockAgent", "is_leaf": true, "is_trunk": false, "source_code": null, "variables": ["self-><Group token=MockAgent type=Class>"]}, "node_ddf17b63": {"uid": "node_ddf17b63", "label": "410: test_batch_emit_with_gather()", "name": "test_eventbus::TestBatchOperations.test_batch_emit_with_gather", "parent": "TestBatchOperations", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["self-><Group token=TestBatchOperations type=Class>"]}, "node_dc02b64d": {"uid": "node_dc02b64d", "label": "1525: test_complex_multi_bus_scenario()", "name": "test_eventbus::TestComplexIntegration.test_complex_multi_bus_scenario", "parent": "TestComplexIntegration", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["app_bus-><Group token=EventBus type=Class>", "auth_bus-><Group token=EventBus type=Class>", "data_bus-><Group token=EventBus type=Class>", "event-><Call owner_token=app_bus token=dispatch>", "self-><Group token=TestComplexIntegration type=Class>"]}, "node_a9c20b50": {"uid": "node_a9c20b50", "label": "525: test_concurrent_emit_calls()", "name": "test_eventbus::TestEdgeCases.test_concurrent_emit_calls", "parent": "TestEdgeCases", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["batch_end-><Call owner_token=None token=min>", "event-><Group token=UserActionEvent type=Class>", "emitted_event-><Call owner_token=eventbus token=dispatch>", "log-><Call owner_token=eventbus token=copy>", "self-><Group token=TestEdgeCases type=Class>"]}, "node_6bd81243": {"uid": "node_6bd81243", "label": "508: test_event_with_complex_data()", "name": "test_eventbus::TestEdgeCases.test_event_with_complex_data", "parent": "TestEdgeCases", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["event-><Group token=SystemEventModel type=Class>", "self-><Group token=TestEdgeCases type=Class>"]}, "node_a7930324": {"uid": "node_a7930324", "label": "554: test_mixed_delay_handlers_maintain_order()", "name": "test_eventbus::TestEdgeCases.test_mixed_delay_handlers_maintain_order", "parent": "TestEdgeCases", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["order-><Call owner_token=event token=get>", "event-><Group token=UserActionEvent type=Class>", "self-><Group token=TestEdgeCases type=Class>"]}, "node_8d040b3e": {"uid": "node_8d040b3e", "label": "487: test_stop_with_pending_events()", "name": "test_eventbus::TestEdgeCases.test_stop_with_pending_events", "parent": "TestEdgeCases", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["bus-><Group token=EventBus type=Class>", "self-><Group token=TestEdgeCases type=Class>"]}, "node_f7d44e12": {"uid": "node_f7d44e12", "label": "378: test_error_handling()", "name": "test_eventbus::TestErrorHandling.test_error_handling", "parent": "TestErrorHandling", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["failing_result-><Call owner_token=None token=next>", "working_result-><Call owner_token=None token=next>", "self-><Group token=TestErrorHandling type=Class>"]}, "node_d050b744": {"uid": "node_d050b744", "label": "99: test_auto_start_and_stop()", "name": "test_eventbus::TestEventBusBasics.test_auto_start_and_stop", "parent": "TestEventBusBasics", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["bus-><Group token=EventBus type=Class>", "self-><Group token=TestEventBusBasics type=Class>"]}, "node_712fa084": {"uid": "node_712fa084", "label": "90: test_eventbus_initialization()", "name": "test_eventbus::TestEventBusBasics.test_eventbus_initialization", "parent": "TestEventBusBasics", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["bus-><Group token=EventBus type=Class>", "self-><Group token=TestEventBusBasics type=Class>"]}, "node_253a79d8": {"uid": "node_253a79d8", "label": "1476: test_by_eventbus_id_and_path()", "name": "test_eventbus::TestEventBusForwarding.test_by_eventbus_id_and_path", "parent": "TestEventBusForwarding", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["bus1-><Group token=EventBus type=Class>", "bus2-><Group token=EventBus type=Class>", "event-><Call owner_token=bus1 token=dispatch>", "main_result-><Call owner_token=None token=next>", "plugin1_result-><Call owner_token=None token=next>", "plugin2_result-><Call owner_token=None token=next>", "self-><Group token=TestEventBusForwarding type=Class>"]}, "node_01da2c3c": {"uid": "node_01da2c3c", "label": "1418: test_forwarding_flattens_results()", "name": "test_eventbus::TestEventBusForwarding.test_forwarding_flattens_results", "parent": "TestEventBusForwarding", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["bus1-><Group token=EventBus type=Class>", "bus2-><Group token=EventBus type=Class>", "bus3-><Group token=EventBus type=Class>", "event-><Call owner_token=bus1 token=dispatch>", "bus1_result-><Call owner_token=None token=next>", "bus2_result-><Call owner_token=None token=next>", "bus3_result-><Call owner_token=None token=next>", "self-><Group token=TestEventBusForwarding type=Class>"]}, "node_c38023ef": {"uid": "node_c38023ef", "label": "877: test_circular_subscription_prevention()", "name": "test_eventbus::TestEventBusHierarchy.test_circular_subscription_prevention", "parent": "TestEventBusHierarchy", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["peer1-><Group token=EventBus type=Class>", "peer2-><Group token=EventBus type=Class>", "peer3-><Group token=EventBus type=Class>", "event-><Group token=UserActionEvent type=Class>", "emitted-><Call owner_token=peer1 token=dispatch>", "event2-><Group token=SystemEventModel type=Class>", "self-><Group token=TestEventBusHierarchy type=Class>"]}, "node_241cff45": {"uid": "node_241cff45", "label": "796: test_tresultsee_level_hierarchy_bubbling()", "name": "test_eventbus::TestEventBusHierarchy.test_tresultsee_level_hierarchy_bubbling", "parent": "TestEventBusHierarchy", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["parent_bus-><Group token=EventBus type=Class>", "child_bus-><Group token=EventBus type=Class>", "subchild_bus-><Group token=EventBus type=Class>", "event-><Group token=UserActionEvent type=Class>", "emitted-><Call owner_token=subchild_bus token=dispatch>", "middle_event-><Group token=SystemEventModel type=Class>", "self-><Group token=TestEventBusHierarchy type=Class>"]}, "node_cba19c72": {"uid": "node_cba19c72", "label": "460: test_wait_for_result()", "name": "test_eventbus::TestEventCompletion.test_wait_for_result", "parent": "TestEventCompletion", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["event-><Call owner_token=eventbus token=dispatch>", "self-><Group token=TestEventCompletion type=Class>"]}, "node_048aa0fd": {"uid": "node_048aa0fd", "label": "127: test_emit_and_result()", "name": "test_eventbus::TestEventEnqueueing.test_emit_and_result", "parent": "TestEventEnqueueing", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["event-><Group token=UserActionEvent type=Class>", "queued-><Call owner_token=eventbus token=dispatch>", "self-><Group token=TestEventEnqueueing type=Class>"]}, "node_2612c774": {"uid": "node_2612c774", "label": "155: test_emit_sync()", "name": "test_eventbus::TestEventEnqueueing.test_emit_sync", "parent": "TestEventEnqueueing", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["bus-><Group token=EventBus type=Class>", "event-><Group token=SystemEventModel type=Class>", "self-><Group token=TestEventEnqueueing type=Class>"]}, "node_3b5bea0a": {"uid": "node_3b5bea0a", "label": "1281: test_by_handler_id()", "name": "test_eventbus::TestEventResults.test_by_handler_id", "parent": "TestEventResults", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["self-><Group token=TestEventResults type=Class>"]}, "node_5c7e07ae": {"uid": "node_5c7e07ae", "label": "1251: test_by_handler_name()", "name": "test_eventbus::TestEventResults.test_by_handler_name", "parent": "TestEventResults", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["unique_result-><Call owner_token=None token=next>", "self-><Group token=TestEventResults type=Class>"]}, "node_cadf27d3": {"uid": "node_cadf27d3", "label": "1376: test_by_handler_name_access()", "name": "test_eventbus::TestEventResults.test_by_handler_name_access", "parent": "TestEventResults", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["handler_a_result-><Call owner_token=None token=next>", "handler_b_result-><Call owner_token=None token=next>", "self-><Group token=TestEventResults type=Class>"]}, "node_d500d440": {"uid": "node_d500d440", "label": "1163: test_dispatch_returns_event_results()", "name": "test_eventbus::TestEventResults.test_dispatch_returns_event_results", "parent": "TestEventResults", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["result-><Call owner_token=eventbus token=dispatch>", "result_no_handlers-><Call owner_token=eventbus token=dispatch>", "self-><Group token=TestEventResults type=Class>"]}, "node_12e97416": {"uid": "node_12e97416", "label": "1222: test_event_results_access()", "name": "test_eventbus::TestEventResults.test_event_results_access", "parent": "TestEventResults", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["early_result-><Call owner_token=None token=next>", "late_result-><Call owner_token=None token=next>", "results_empty-><Call owner_token=eventbus token=dispatch>", "self-><Group token=TestEventResults type=Class>"]}, "node_f7b0a85e": {"uid": "node_f7b0a85e", "label": "1190: test_event_results_indexing()", "name": "test_eventbus::TestEventResults.test_event_results_indexing", "parent": "TestEventResults", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["handler1_result-><Call owner_token=None token=next>", "handler2_result-><Call owner_token=None token=next>", "handler3_result-><Call owner_token=None token=next>", "self-><Group token=TestEventResults type=Class>"]}, "node_0bf3ab27": {"uid": "node_0bf3ab27", "label": "1309: test_flat_dict()", "name": "test_eventbus::TestEventResults.test_flat_dict", "parent": "TestEventResults", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["self-><Group token=TestEventResults type=Class>"]}, "node_c9fd4ab8": {"uid": "node_c9fd4ab8", "label": "1343: test_flat_list()", "name": "test_eventbus::TestEventResults.test_flat_list", "parent": "TestEventResults", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["self-><Group token=TestEventResults type=Class>"]}, "node_68b00637": {"uid": "node_68b00637", "label": "1397: test_string_indexing()", "name": "test_eventbus::TestEventResults.test_string_indexing", "parent": "TestEventResults", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["my_handler_result-><Call owner_token=None token=next>", "missing_result-><Call owner_token=None token=next>", "self-><Group token=TestEventResults type=Class>"]}, "node_f41b9575": {"uid": "node_f41b9575", "label": "630: test_automatic_event_type_derivation()", "name": "test_eventbus::TestEventTypeOverride.test_automatic_event_type_derivation", "parent": "TestEventTypeOverride", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["event-><Group token=UserActionEvent type=Class>", "event2-><Group token=SystemEventModel type=Class>", "inline_event-><Call owner_token=None token=InlineTestEvent>", "self-><Group token=TestEventTypeOverride type=Class>"]}, "node_3e7a5413": {"uid": "node_3e7a5413", "label": "609: test_event_schema_auto_generation()", "name": "test_eventbus::TestEventTypeOverride.test_event_schema_auto_generation", "parent": "TestEventTypeOverride", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["version-><Call owner_token=os token=getenv>", "base_event-><Group token=BaseEvent type=Class>", "task_event-><Group token=CreateAgentTaskEvent type=Class>", "user_event-><Group token=UserActionEvent type=Class>", "result-><Call owner_token=eventbus token=dispatch>", "self-><Group token=TestEventTypeOverride type=Class>"]}, "node_0026066b": {"uid": "node_0026066b", "label": "594: test_event_subclass_type()", "name": "test_eventbus::TestEventTypeOverride.test_event_subclass_type", "parent": "TestEventTypeOverride", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["event-><Group token=CreateAgentTaskEvent type=Class>", "result-><Call owner_token=eventbus token=dispatch>", "self-><Group token=TestEventTypeOverride type=Class>"]}, "node_642ca7f7": {"uid": "node_642ca7f7", "label": "664: test_explicit_event_type_override()", "name": "test_eventbus::TestEventTypeOverride.test_explicit_event_type_override", "parent": "TestEventTypeOverride", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["event-><Call owner_token=None token=OverrideEvent>", "self-><Group token=TestEventTypeOverride type=Class>"]}, "node_9d304421": {"uid": "node_9d304421", "label": "969: test_expect_basic()", "name": "test_eventbus::TestExpectMethod.test_expect_basic", "parent": "TestExpectMethod", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["expect_task-><Call owner_token=asyncio token=create_task>", "dispatched-><Call owner_token=eventbus token=dispatch>", "self-><Group token=TestExpectMethod type=Class>"]}, "node_038b752d": {"uid": "node_038b752d", "label": "1063: test_expect_handler_cleanup()", "name": "test_eventbus::TestExpectMethod.test_expect_handler_cleanup", "parent": "TestExpectMethod", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["initial_handlers-><Call owner_token=None token=len>", "expect_task-><Call owner_token=asyncio token=create_task>", "self-><Group token=TestExpectMethod type=Class>"]}, "node_733ef27f": {"uid": "node_733ef27f", "label": "1143: test_expect_in_sync_context()", "name": "test_eventbus::TestExpectMethod.test_expect_in_sync_context", "parent": "TestExpectMethod", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["bus-><Group token=EventBus type=Class>", "expect_coroutine-><Call owner_token=bus token=expect>", "self-><Group token=TestExpectMethod type=Class>"]}, "node_d2efc9ce": {"uid": "node_d2efc9ce", "label": "1086: test_expect_receives_completed_event()", "name": "test_eventbus::TestExpectMethod.test_expect_receives_completed_event", "parent": "TestExpectMethod", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["expect_task-><Call owner_token=asyncio token=create_task>", "self-><Group token=TestExpectMethod type=Class>"]}, "node_aebe1a62": {"uid": "node_aebe1a62", "label": "1015: test_expect_timeout()", "name": "test_eventbus::TestExpectMethod.test_expect_timeout", "parent": "TestExpectMethod", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["self-><Group token=TestExpectMethod type=Class>"]}, "node_e6995eab": {"uid": "node_e6995eab", "label": "1116: test_expect_with_complex_predicate()", "name": "test_eventbus::TestExpectMethod.test_expect_with_complex_predicate", "parent": "TestExpectMethod", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["expect_task-><Call owner_token=asyncio token=create_task>", "self-><Group token=TestExpectMethod type=Class>"]}, "node_a954efc3": {"uid": "node_a954efc3", "label": "1021: test_expect_with_model_class()", "name": "test_eventbus::TestExpectMethod.test_expect_with_model_class", "parent": "TestExpectMethod", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["expect_task-><Call owner_token=asyncio token=create_task>", "target-><Call owner_token=eventbus token=dispatch>", "self-><Group token=TestExpectMethod type=Class>"]}, "node_8d8b0707": {"uid": "node_8d8b0707", "label": "989: test_expect_with_predicate()", "name": "test_eventbus::TestExpectMethod.test_expect_with_predicate", "parent": "TestExpectMethod", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["expect_task-><Call owner_token=asyncio token=create_task>", "target_event-><Call owner_token=eventbus token=dispatch>", "self-><Group token=TestExpectMethod type=Class>"]}, "node_d366670c": {"uid": "node_d366670c", "label": "1038: test_multiple_concurrent_expects()", "name": "test_eventbus::TestExpectMethod.test_multiple_concurrent_expects", "parent": "TestExpectMethod", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["expect1-><Call owner_token=asyncio token=create_task>", "expect2-><Call owner_token=asyncio token=create_task>", "expect3-><Call owner_token=asyncio token=create_task>", "e1-><Call owner_token=eventbus token=dispatch>", "e2-><Call owner_token=eventbus token=dispatch>", "e3-><Call owner_token=eventbus token=dispatch>", "self-><Group token=TestExpectMethod type=Class>"]}, "node_6825d133": {"uid": "node_6825d133", "label": "344: test_fifo_with_varying_handler_delays()", "name": "test_eventbus::TestFIFOOrdering.test_fifo_with_varying_handler_delays", "parent": "TestFIFOOrdering", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["order-><Call owner_token=event token=get>", "self-><Group token=TestFIFOOrdering type=Class>"]}, "node_d6cb9cd8": {"uid": "node_d6cb9cd8", "label": "259: test_class_and_instance_method_handlers()", "name": "test_eventbus::TestHandlerRegistration.test_class_and_instance_method_handlers", "parent": "TestHandlerRegistration", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["processor1-><Call owner_token=None token=EventProcessor>", "processor2-><Call owner_token=None token=EventProcessor>", "event-><Group token=UserActionEvent type=Class>", "p1_sync_result-><Call owner_token=None token=next>", "p1_async_result-><Call owner_token=None token=next>", "p2_sync_result-><Call owner_token=None token=next>", "self-><Group token=TestHandlerRegistration type=Class>"]}, "node_dd88d50a": {"uid": "node_dd88d50a", "label": "242: test_handler_can_be_sync_or_async()", "name": "test_eventbus::TestHandlerRegistration.test_handler_can_be_sync_or_async", "parent": "TestHandlerRegistration", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["bus-><Group token=EventBus type=Class>", "self-><Group token=TestHandlerRegistration type=Class>"]}, "node_9ee39f9b": {"uid": "node_9ee39f9b", "label": "170: test_handler_registration()", "name": "test_eventbus::TestHandlerRegistration.test_handler_registration", "parent": "TestHandlerRegistration", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["self-><Group token=TestHandlerRegistration type=Class>"]}, "node_fb05839a": {"uid": "node_fb05839a", "label": "204: test_multiple_handlers_parallel()", "name": "test_eventbus::TestHandlerRegistration.test_multiple_handlers_parallel", "parent": "TestHandlerRegistration", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["start-><Call owner_token=time token=time>", "handler1_result-><Call owner_token=None token=next>", "handler2_result-><Call owner_token=None token=next>", "self-><Group token=TestHandlerRegistration type=Class>"]}, "node_a602a0ec": {"uid": "node_a602a0ec", "label": "731: test_wal_persistence_creates_parent_dir()", "name": "test_eventbus::TestWALPersistence.test_wal_persistence_creates_parent_dir", "parent": "TestWALPersistence", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["bus-><Group token=EventBus type=Class>", "event-><Call owner_token=bus token=dispatch>", "self-><Group token=TestWALPersistence type=Class>"]}, "node_05bb60e2": {"uid": "node_05bb60e2", "label": "694: test_wal_persistence_handler()", "name": "test_eventbus::TestWALPersistence.test_wal_persistence_handler", "parent": "TestWALPersistence", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["bus-><Group token=EventBus type=Class>", "lines-><Call owner_token=UNKNOWN_VAR token=split>", "event-><Group token=UserActionEvent type=Class>", "emitted_event-><Call owner_token=bus token=dispatch>", "data-><Call owner_token=json token=loads>", "self-><Group token=TestWALPersistence type=Class>"]}, "node_64af79cd": {"uid": "node_64af79cd", "label": "756: test_wal_persistence_skips_incomplete_events()", "name": "test_eventbus::TestWALPersistence.test_wal_persistence_skips_incomplete_events", "parent": "TestWALPersistence", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["bus-><Group token=EventBus type=Class>", "event-><Call owner_token=bus token=dispatch>", "lines-><Call owner_token=UNKNOWN_VAR token=split>", "data-><Call owner_token=json token=loads>", "self-><Group token=TestWALPersistence type=Class>"]}, "node_7f04e1c6": {"uid": "node_7f04e1c6", "label": "431: test_write_ahead_log_captures_all_events()", "name": "test_eventbus::TestWriteAheadLog.test_write_ahead_log_captures_all_events", "parent": "TestWriteAheadLog", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["event-><Group token=UserActionEvent type=Class>", "log-><Call owner_token=eventbus token=copy>", "self-><Group token=TestWriteAheadLog type=Class>"]}, "node_eb143f95": {"uid": "node_eb143f95", "label": "66: eventbus()", "name": "test_eventbus::eventbus", "parent": "test_eventbus", "is_leaf": false, "is_trunk": true, "source_code": "async def eventbus():\n    \"\"\"Create an event bus for testing\"\"\"\n    bus = EventBus(max_history_size=10000)  # Increase history limit for tests\n    yield bus\n    await bus.stop()", "variables": ["bus-><Group token=EventBus type=Class>"]}, "node_8b076e53": {"uid": "node_8b076e53", "label": "82: mock_agent()", "name": "test_eventbus::mock_agent", "parent": "test_eventbus", "is_leaf": false, "is_trunk": true, "source_code": "def mock_agent():\n    \"\"\"Create a mock agent\"\"\"\n    return MockAgent()", "variables": []}, "node_506e63e3": {"uid": "node_506e63e3", "label": "74: parallel_eventbus()", "name": "test_eventbus::parallel_eventbus", "parent": "test_eventbus", "is_leaf": false, "is_trunk": true, "source_code": "async def parallel_eventbus():\n    \"\"\"Create an event bus with parallel handler execution\"\"\"\n    bus = EventBus(parallel_handlers=True)\n    yield bus\n    await bus.stop()", "variables": ["bus-><Group token=EventBus type=Class>"]}, "node_c5ef864d": {"uid": "node_c5ef864d", "label": "111: test_log_history_tree_complex_nested()", "name": "test_log_history_tree::test_log_history_tree_complex_nested", "parent": "test_log_history_tree", "is_leaf": false, "is_trunk": true, "source_code": "def test_log_history_tree_complex_nested() -> None:\n    \"\"\"Test tree output with complex nested events\"\"\"\n    bus = EventBus(name='ComplexBus')\n\n    # Create root event\n    root = RootEvent(data='root_data')\n    root.event_processed_at = datetime.now(UTC)\n\n    # Add root handler with child events\n    root_handler_id = f'{id(bus)}.1001'\n    root.event_results[root_handler_id] = EventResult(\n        event_id=root.event_id,\n        handler_id=root_handler_id,\n        handler_name='root_handler',\n        eventbus_id=str(id(bus)),\n        eventbus_name='ComplexBus',\n        status='completed',\n        started_at=datetime.now(UTC),\n        completed_at=datetime.now(UTC),\n        result='Root processed',\n    )\n\n    # Create child event\n    child = ChildEvent(value=100)\n    child.event_parent_id = root.event_id\n    child.event_processed_at = datetime.now(UTC)\n\n    # Add child to root handler's event_children\n    root.event_results[root_handler_id].event_children.append(child)\n\n    # Add child handler with grandchild\n    child_handler_id = f'{id(bus)}.2001'\n    child.event_results[child_handler_id] = EventResult(\n        event_id=child.event_id,\n        handler_id=child_handler_id,\n        handler_name='child_handler',\n        eventbus_id=str(id(bus)),\n        eventbus_name='ComplexBus',\n        status='completed',\n        started_at=datetime.now(UTC),\n        completed_at=datetime.now(UTC),\n        result=[1, 2, 3],\n    )\n\n    # Create grandchild\n    grandchild = GrandchildEvent()\n    grandchild.event_parent_id = child.event_id\n    grandchild.event_processed_at = datetime.now(UTC)\n\n    # Add grandchild to child handler's event_children\n    child.event_results[child_handler_id].event_children.append(grandchild)\n\n    # Add grandchild handler\n    grandchild_handler_id = f'{id(bus)}.3001'\n    grandchild.event_results[grandchild_handler_id] = EventResult(\n        event_id=grandchild.event_id,\n        handler_id=grandchild_handler_id,\n        handler_name='grandchild_handler',\n        eventbus_id=str(id(bus)),\n        eventbus_name='ComplexBus',\n        status='completed',\n        started_at=datetime.now(UTC),\n        completed_at=datetime.now(UTC),\n        result=None,\n    )\n\n    # Add all to history\n    bus.event_history[root.event_id] = root\n    bus.event_history[child.event_id] = child\n    bus.event_history[grandchild.event_id] = grandchild\n\n    # Capture output\n    captured_output = StringIO()\n    sys.stdout = captured_output\n\n    try:\n        bus.log_tree()\n        output = captured_output.getvalue()\n    finally:\n        sys.stdout = sys.__stdout__\n\n    # Check structure - note that events may appear both as handler children and in parent mapping\n    assert '\u2514\u2500\u2500 \u2705 RootEvent#' in output\n    assert '\u2705 ComplexBus.root_handler#' in output\n    assert '\u2705 ChildEvent#' in output\n    assert '\u2705 ComplexBus.child_handler#' in output\n    assert '\u2705 GrandchildEvent#' in output\n    assert '\u2705 ComplexBus.grandchild_handler#' in output\n\n    # Check result formatting\n    assert \"'Root processed'\" in output\n    assert 'list(3 items)' in output\n    assert 'None' in output", "variables": ["bus-><Group token=EventBus type=Class>", "root-><Group token=RootEvent type=Class>", "child-><Group token=ChildEvent type=Class>", "grandchild-><Group token=GrandchildEvent type=Class>", "captured_output-><Call owner_token=None token=StringIO>", "output-><Call owner_token=captured_output token=getvalue>"]}, "node_29f27802": {"uid": "node_29f27802", "label": "24: test_log_history_tree_empty()", "name": "test_log_history_tree::test_log_history_tree_empty", "parent": "test_log_history_tree", "is_leaf": false, "is_trunk": true, "source_code": "def test_log_history_tree_empty(capsys: Any) -> None:\n    \"\"\"Test tree output with empty history\"\"\"\n    bus = EventBus(name='EmptyBus')\n    bus.log_tree()\n\n    captured = capsys.readouterr()\n    assert 'Event History Tree for EmptyBus' in captured.out\n    assert '(No events in history)' in captured.out", "variables": ["bus-><Group token=EventBus type=Class>", "captured-><Call owner_token=capsys token=readouterr>"]}, "node_b2c37c79": {"uid": "node_b2c37c79", "label": "206: test_log_history_tree_multiple_roots()", "name": "test_log_history_tree::test_log_history_tree_multiple_roots", "parent": "test_log_history_tree", "is_leaf": false, "is_trunk": true, "source_code": "def test_log_history_tree_multiple_roots(capsys: Any) -> None:\n    \"\"\"Test tree output with multiple root events\"\"\"\n    bus = EventBus(name='MultiBus')\n\n    # Create multiple root events\n    root1 = RootEvent(data='first')\n    root1.event_processed_at = datetime.now(UTC)\n\n    root2 = RootEvent(data='second')\n    root2.event_processed_at = datetime.now(UTC)\n\n    bus.event_history[root1.event_id] = root1\n    bus.event_history[root2.event_id] = root2\n\n    bus.log_tree()\n\n    captured = capsys.readouterr()\n    # Both roots should be shown\n    assert captured.out.count('\u251c\u2500\u2500 \u2705 RootEvent#') == 1  # First root\n    assert captured.out.count('\u2514\u2500\u2500 \u2705 RootEvent#') == 1", "variables": ["bus-><Group token=EventBus type=Class>", "root1-><Group token=RootEvent type=Class>", "root2-><Group token=RootEvent type=Class>", "captured-><Call owner_token=capsys token=readouterr>"]}, "node_24d7b799": {"uid": "node_24d7b799", "label": "261: test_log_history_tree_running_handler()", "name": "test_log_history_tree::test_log_history_tree_running_handler", "parent": "test_log_history_tree", "is_leaf": false, "is_trunk": true, "source_code": "def test_log_history_tree_running_handler(capsys: Any) -> None:\n    \"\"\"Test tree output with handlers still running\"\"\"\n    bus = EventBus(name='RunningBus')\n\n    event = RootEvent()\n\n    # Add running handler (started but not completed)\n    handler_id = f'{id(bus)}.555'\n    event.event_results[handler_id] = EventResult(\n        event_id=event.event_id,\n        handler_id=handler_id,\n        handler_name='running_handler',\n        eventbus_id=str(id(bus)),\n        eventbus_name='RunningBus',\n        status='started',\n        started_at=datetime.now(UTC),\n        completed_at=None,\n    )\n\n    bus.event_history[event.event_id] = event\n    bus.log_tree()\n\n    captured = capsys.readouterr()\n    assert '\ud83c\udfc3 RunningBus.running_handler#' in captured.out\n    assert '\ud83c\udfc3 RootEvent#' in captured.out", "variables": ["bus-><Group token=EventBus type=Class>", "event-><Group token=RootEvent type=Class>", "captured-><Call owner_token=capsys token=readouterr>"]}, "node_44b539ff": {"uid": "node_44b539ff", "label": "34: test_log_history_tree_single_event()", "name": "test_log_history_tree::test_log_history_tree_single_event", "parent": "test_log_history_tree", "is_leaf": false, "is_trunk": true, "source_code": "def test_log_history_tree_single_event(capsys: Any) -> None:\n    \"\"\"Test tree output with a single event\"\"\"\n    bus = EventBus(name='SingleBus')\n\n    # Create and add event to history\n    event = RootEvent(data='test')\n    event.event_processed_at = datetime.now(UTC)\n    bus.event_history[event.event_id] = event\n\n    bus.log_tree()\n\n    captured = capsys.readouterr()\n    assert '\u2514\u2500\u2500 \u2705 RootEvent#' in captured.out\n    # Should show start time and duration\n    assert '[' in captured.out and ']' in captured.out", "variables": ["bus-><Group token=EventBus type=Class>", "event-><Group token=RootEvent type=Class>", "captured-><Call owner_token=capsys token=readouterr>"]}, "node_ab41b685": {"uid": "node_ab41b685", "label": "228: test_log_history_tree_timing_info()", "name": "test_log_history_tree::test_log_history_tree_timing_info", "parent": "test_log_history_tree", "is_leaf": false, "is_trunk": true, "source_code": "def test_log_history_tree_timing_info(capsys: Any) -> None:\n    \"\"\"Test that timing information is displayed correctly\"\"\"\n    bus = EventBus(name='TimingBus')\n\n    event = RootEvent()\n    event.event_processed_at = datetime.now(UTC)\n\n    # Add handler with timing\n    start_time = datetime.now(UTC)\n    end_time = datetime.now(UTC)\n\n    handler_id = f'{id(bus)}.999'\n    event.event_results[handler_id] = EventResult(\n        event_id=event.event_id,\n        handler_id=handler_id,\n        handler_name='timed_handler',\n        eventbus_id=str(id(bus)),\n        eventbus_name='TimingBus',\n        status='completed',\n        started_at=start_time,\n        completed_at=end_time,\n        result='done',\n    )\n\n    bus.event_history[event.event_id] = event\n    bus.log_tree()\n\n    captured = capsys.readouterr()\n    # Should show timing with duration\n    assert '(' in captured.out  # Opening parenthesis for duration\n    assert 's)' in captured.out", "variables": ["bus-><Group token=EventBus type=Class>", "event-><Group token=RootEvent type=Class>", "start_time-><Call owner_token=datetime token=now>", "end_time-><Call owner_token=datetime token=now>", "captured-><Call owner_token=capsys token=readouterr>"]}, "node_369c2399": {"uid": "node_369c2399", "label": "82: test_log_history_tree_with_errors()", "name": "test_log_history_tree::test_log_history_tree_with_errors", "parent": "test_log_history_tree", "is_leaf": false, "is_trunk": true, "source_code": "def test_log_history_tree_with_errors(capsys: Any) -> None:\n    \"\"\"Test tree output with handler errors\"\"\"\n    bus = EventBus(name='ErrorBus')\n\n    event = RootEvent()\n    event.event_processed_at = datetime.now(UTC)\n\n    # Add error result\n    handler_id = f'{id(bus)}.789'\n    event.event_results[handler_id] = EventResult(\n        event_id=event.event_id,\n        handler_id=handler_id,\n        handler_name='error_handler',\n        eventbus_id=str(id(bus)),\n        eventbus_name='ErrorBus',\n        status='error',\n        started_at=datetime.now(UTC),\n        completed_at=datetime.now(UTC),\n        error=ValueError('Test error message'),\n    )\n\n    bus.event_history[event.event_id] = event\n    bus.log_tree()\n\n    captured = capsys.readouterr()\n    assert '\u274c ErrorBus.error_handler#' in captured.out\n    assert '\u274c ValueError: Test error message' in captured.out", "variables": ["bus-><Group token=EventBus type=Class>", "event-><Group token=RootEvent type=Class>", "captured-><Call owner_token=capsys token=readouterr>"]}, "node_d30f35f9": {"uid": "node_d30f35f9", "label": "51: test_log_history_tree_with_handlers()", "name": "test_log_history_tree::test_log_history_tree_with_handlers", "parent": "test_log_history_tree", "is_leaf": false, "is_trunk": true, "source_code": "def test_log_history_tree_with_handlers(capsys: Any) -> None:\n    \"\"\"Test tree output with event handlers and results\"\"\"\n    bus = EventBus(name='HandlerBus')\n\n    # Create event with handler results\n    event = RootEvent(data='test')\n    event.event_processed_at = datetime.now(UTC)\n\n    # Add handler result\n    handler_id = f'{id(bus)}.123456'\n    event.event_results[handler_id] = EventResult(\n        event_id=event.event_id,\n        handler_id=handler_id,\n        handler_name='test_handler',\n        eventbus_id=str(id(bus)),\n        eventbus_name='HandlerBus',\n        status='completed',\n        started_at=datetime.now(UTC),\n        completed_at=datetime.now(UTC),\n        result={'status': 'success'},\n    )\n\n    bus.event_history[event.event_id] = event\n    bus.log_tree()\n\n    captured = capsys.readouterr()\n    assert '\u2514\u2500\u2500 \u2705 RootEvent#' in captured.out\n    assert '\u2514\u2500\u2500 \u2705 HandlerBus.test_handler#' in captured.out\n    assert 'dict(1 items)' in captured.out", "variables": ["bus-><Group token=EventBus type=Class>", "event-><Group token=RootEvent type=Class>", "captured-><Call owner_token=capsys token=readouterr>"]}, "node_1dae6dea": {"uid": "node_1dae6dea", "label": "147: test_concurrent_name_creation()", "name": "test_name_conflict_gc::TestNameConflictGC.test_concurrent_name_creation", "parent": "TestNameConflictGC", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["bus1-><Group token=EventBus type=Class>", "bus2-><Group token=EventBus type=Class>", "self-><Group token=TestNameConflictGC type=Class>"]}, "node_f62cc789": {"uid": "node_f62cc789", "label": "133: test_eventbus_removed_from_weakset()", "name": "test_name_conflict_gc::TestNameConflictGC.test_eventbus_removed_from_weakset", "parent": "TestNameConflictGC", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["bus-><Group token=EventBus type=Class>", "self-><Group token=TestNameConflictGC type=Class>"]}, "node_03d78f82": {"uid": "node_03d78f82", "label": "74: test_multiple_buses_with_gc()", "name": "test_name_conflict_gc::TestNameConflictGC.test_multiple_buses_with_gc", "parent": "TestNameConflictGC", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["bus1-><Group token=EventBus type=Class>", "bus3-><Group token=EventBus type=Class>", "bus2_new-><Group token=EventBus type=Class>", "bus4_new-><Group token=EventBus type=Class>", "bus1_conflict-><Group token=EventBus type=Class>", "bus3_conflict-><Group token=EventBus type=Class>", "self-><Group token=TestNameConflictGC type=Class>"]}, "node_97cb342f": {"uid": "node_97cb342f", "label": "96: test_name_conflict_after_stop_and_clear()", "name": "test_name_conflict_gc::TestNameConflictGC.test_name_conflict_after_stop_and_clear", "parent": "TestNameConflictGC", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["bus1-><Group token=EventBus type=Class>", "bus2-><Group token=EventBus type=Class>", "self-><Group token=TestNameConflictGC type=Class>"]}, "node_21815d1e": {"uid": "node_21815d1e", "label": "19: test_name_conflict_with_live_reference()", "name": "test_name_conflict_gc::TestNameConflictGC.test_name_conflict_with_live_reference", "parent": "TestNameConflictGC", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["bus1-><Group token=EventBus type=Class>", "bus2-><Group token=EventBus type=Class>", "self-><Group token=TestNameConflictGC type=Class>"]}, "node_52241b57": {"uid": "node_52241b57", "label": "54: test_name_conflict_with_weak_reference_only()", "name": "test_name_conflict_gc::TestNameConflictGC.test_name_conflict_with_weak_reference_only", "parent": "TestNameConflictGC", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["bus1-><Group token=EventBus type=Class>", "weak_ref-><Call owner_token=weakref token=ref>", "bus2-><Group token=EventBus type=Class>", "self-><Group token=TestNameConflictGC type=Class>"]}, "node_dbd68930": {"uid": "node_dbd68930", "label": "33: test_name_no_conflict_after_deletion()", "name": "test_name_conflict_gc::TestNameConflictGC.test_name_no_conflict_after_deletion", "parent": "TestNameConflictGC", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["bus1-><Group token=EventBus type=Class>", "bus2-><Group token=EventBus type=Class>", "self-><Group token=TestNameConflictGC type=Class>"]}, "node_baa2c259": {"uid": "node_baa2c259", "label": "45: test_name_no_conflict_with_no_reference()", "name": "test_name_conflict_gc::TestNameConflictGC.test_name_no_conflict_with_no_reference", "parent": "TestNameConflictGC", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["bus2-><Group token=EventBus type=Class>", "self-><Group token=TestNameConflictGC type=Class>"]}, "node_8212364e": {"uid": "node_8212364e", "label": "111: test_weakset_behavior()", "name": "test_name_conflict_gc::TestNameConflictGC.test_weakset_behavior", "parent": "TestNameConflictGC", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["initial_count-><Call owner_token=None token=len>", "bus1-><Group token=EventBus type=Class>", "bus2-><Group token=EventBus type=Class>", "bus3-><Group token=EventBus type=Class>", "self-><Group token=TestNameConflictGC type=Class>"]}, "node_c8d965b8": {"uid": "node_c8d965b8", "label": "41: test_basic_parent_tracking()", "name": "test_parent_event_tracking::TestParentEventTracking.test_basic_parent_tracking", "parent": "TestParentEventTracking", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["child-><Group token=ChildEvent type=Class>", "parent-><Group token=ParentEvent type=Class>", "parent_result-><Call owner_token=eventbus token=dispatch>", "parent_handler_result-><Call owner_token=None token=next>", "self-><Group token=TestParentEventTracking type=Class>"]}, "node_5b5bc21a": {"uid": "node_5b5bc21a", "label": "199: test_cross_eventbus_parent_tracking()", "name": "test_parent_event_tracking::TestParentEventTracking.test_cross_eventbus_parent_tracking", "parent": "TestParentEventTracking", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["bus1-><Group token=EventBus type=Class>", "bus2-><Group token=EventBus type=Class>", "child-><Group token=ChildEvent type=Class>", "parent-><Group token=ParentEvent type=Class>", "self-><Group token=TestParentEventTracking type=Class>"]}, "node_09730a51": {"uid": "node_09730a51", "label": "262: test_error_handler_parent_tracking()", "name": "test_parent_event_tracking::TestParentEventTracking.test_error_handler_parent_tracking", "parent": "TestParentEventTracking", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["child-><Group token=ChildEvent type=Class>", "child-><Group token=ChildEvent type=Class>", "parent-><Group token=ParentEvent type=Class>", "self-><Group token=TestParentEventTracking type=Class>"]}, "node_1ee5dbaf": {"uid": "node_1ee5dbaf", "label": "174: test_explicit_parent_not_overridden()", "name": "test_parent_event_tracking::TestParentEventTracking.test_explicit_parent_not_overridden", "parent": "TestParentEventTracking", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["child-><Group token=ChildEvent type=Class>", "parent-><Group token=ParentEvent type=Class>", "self-><Group token=TestParentEventTracking type=Class>"]}, "node_cee73279": {"uid": "node_cee73279", "label": "73: test_multi_level_parent_tracking()", "name": "test_parent_event_tracking::TestParentEventTracking.test_multi_level_parent_tracking", "parent": "TestParentEventTracking", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["child-><Group token=ChildEvent type=Class>", "grandchild-><Group token=GrandchildEvent type=Class>", "parent-><Group token=ParentEvent type=Class>", "self-><Group token=TestParentEventTracking type=Class>"]}, "node_1e15eda0": {"uid": "node_1e15eda0", "label": "115: test_multiple_children_same_parent()", "name": "test_parent_event_tracking::TestParentEventTracking.test_multiple_children_same_parent", "parent": "TestParentEventTracking", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["child-><Group token=ChildEvent type=Class>", "parent-><Group token=ParentEvent type=Class>", "self-><Group token=TestParentEventTracking type=Class>"]}, "node_9a317753": {"uid": "node_9a317753", "label": "140: test_parallel_handlers_parent_tracking()", "name": "test_parent_event_tracking::TestParentEventTracking.test_parallel_handlers_parent_tracking", "parent": "TestParentEventTracking", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["child-><Group token=ChildEvent type=Class>", "child-><Group token=ChildEvent type=Class>", "parent-><Group token=ParentEvent type=Class>", "self-><Group token=TestParentEventTracking type=Class>"]}, "node_9155d7ea": {"uid": "node_9155d7ea", "label": "240: test_sync_handler_parent_tracking()", "name": "test_parent_event_tracking::TestParentEventTracking.test_sync_handler_parent_tracking", "parent": "TestParentEventTracking", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["child-><Group token=ChildEvent type=Class>", "parent-><Group token=ParentEvent type=Class>", "self-><Group token=TestParentEventTracking type=Class>"]}, "node_f89333cb": {"uid": "node_f89333cb", "label": "31: eventbus()", "name": "test_parent_event_tracking::eventbus", "parent": "test_parent_event_tracking", "is_leaf": false, "is_trunk": true, "source_code": "async def eventbus():\n    \"\"\"Create an event bus for testing\"\"\"\n    bus = EventBus(name='TestBus')\n    yield bus\n    await bus.stop(clear=True)", "variables": ["bus-><Group token=EventBus type=Class>"]}, "node_f5020787": {"uid": "node_f5020787", "label": "178: test_basic_multiprocess_semaphore()", "name": "test_semaphores::TestMultiprocessSemaphore.test_basic_multiprocess_semaphore", "parent": "TestMultiprocessSemaphore", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["start_time-><Call owner_token=time token=time>", "p-><Call owner_token=multiprocessing token=Process>", "p-><Call owner_token=multiprocessing token=Process>", "first_three-><Call owner_token=None token=set>", "last_three-><Call owner_token=None token=set>", "self-><Group token=TestMultiprocessSemaphore type=Class>"]}, "node_24c55f61": {"uid": "node_24c55f61", "label": "335: test_concurrent_acquisition_order()", "name": "test_semaphores::TestMultiprocessSemaphore.test_concurrent_acquisition_order", "parent": "TestMultiprocessSemaphore", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["start_time-><Call owner_token=time token=time>", "p-><Call owner_token=multiprocessing token=Process>", "p-><Call owner_token=multiprocessing token=Process>", "min_release-><Call owner_token=None token=min>", "min_second_acquire-><Call owner_token=None token=min>", "self-><Group token=TestMultiprocessSemaphore type=Class>"]}, "node_b33ef3d5": {"uid": "node_b33ef3d5", "label": "288: test_process_death_releases_semaphore()", "name": "test_semaphores::TestMultiprocessSemaphore.test_process_death_releases_semaphore", "parent": "TestMultiprocessSemaphore", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["start_time-><Call owner_token=time token=time>", "p-><Call owner_token=multiprocessing token=Process>", "p-><Call owner_token=multiprocessing token=Process>", "self-><Group token=TestMultiprocessSemaphore type=Class>"]}, "node_9a47a820": {"uid": "node_9a47a820", "label": "401: test_semaphore_persistence_across_runs()", "name": "test_semaphores::TestMultiprocessSemaphore.test_semaphore_persistence_across_runs", "parent": "TestMultiprocessSemaphore", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["start_time-><Call owner_token=time token=time>", "p-><Call owner_token=multiprocessing token=Process>", "timeout_worker-><Call owner_token=multiprocessing token=Process>", "p-><Call owner_token=multiprocessing token=Process>", "min_release_time-><Call owner_token=None token=min>", "self-><Group token=TestMultiprocessSemaphore type=Class>"]}, "node_8f56a8c6": {"uid": "node_8f56a8c6", "label": "242: test_semaphore_timeout()", "name": "test_semaphores::TestMultiprocessSemaphore.test_semaphore_timeout", "parent": "TestMultiprocessSemaphore", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["start_time-><Call owner_token=time token=time>", "p-><Call owner_token=multiprocessing token=Process>", "p-><Call owner_token=multiprocessing token=Process>", "self-><Group token=TestMultiprocessSemaphore type=Class>"]}, "node_0c047fb5": {"uid": "node_0c047fb5", "label": "502: test_class_scope()", "name": "test_semaphores::TestRegularSemaphoreScopes.test_class_scope", "parent": "TestRegularSemaphoreScopes", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["obj1-><Call owner_token=None token=TestClass>", "obj2-><Call owner_token=None token=TestClass>", "start_time-><Call owner_token=time token=time>", "end_time-><Call owner_token=time token=time>", "self-><Group token=TestRegularSemaphoreScopes type=Class>"]}, "node_f16c3b28": {"uid": "node_f16c3b28", "label": "471: test_global_scope()", "name": "test_semaphores::TestRegularSemaphoreScopes.test_global_scope", "parent": "TestRegularSemaphoreScopes", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["self-><Group token=TestRegularSemaphoreScopes type=Class>"]}, "node_658acb00": {"uid": "node_658acb00", "label": "538: test_self_scope()", "name": "test_semaphores::TestRegularSemaphoreScopes.test_self_scope", "parent": "TestRegularSemaphoreScopes", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["obj1-><Call owner_token=None token=TestClass>", "obj2-><Call owner_token=None token=TestClass>", "start_time-><Call owner_token=time token=time>", "end_time-><Call owner_token=time token=time>", "self-><Group token=TestRegularSemaphoreScopes type=Class>"]}, "node_c09f68c0": {"uid": "node_c09f68c0", "label": "578: test_retry_decorator_on_eventbus_handler()", "name": "test_semaphores::TestRetryWithEventBus.test_retry_decorator_on_eventbus_handler", "parent": "TestRetryWithEventBus", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["BaseEvent->UNKNOWN_MODULE", "EventBus->UNKNOWN_MODULE", "bus-><Group token=EventBus type=Class>", "call_time-><Call owner_token=time token=time>", "event-><Call owner_token=None token=TestEvent>", "self-><Group token=TestRetryWithEventBus type=Class>"]}, "node_d6a04c1e": {"uid": "node_d6a04c1e", "label": "717: test_retry_timeout_with_eventbus_handler()", "name": "test_semaphores::TestRetryWithEventBus.test_retry_timeout_with_eventbus_handler", "parent": "TestRetryWithEventBus", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["BaseEvent->UNKNOWN_MODULE", "EventBus->UNKNOWN_MODULE", "bus-><Group token=EventBus type=Class>", "event-><Call owner_token=None token=TimeoutEvent>", "self-><Group token=TestRetryWithEventBus type=Class>"]}, "node_7b4df7f5": {"uid": "node_7b4df7f5", "label": "766: test_retry_with_event_type_filter()", "name": "test_semaphores::TestRetryWithEventBus.test_retry_with_event_type_filter", "parent": "TestRetryWithEventBus", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["BaseEvent->UNKNOWN_MODULE", "EventBus->UNKNOWN_MODULE", "bus-><Group token=EventBus type=Class>", "event-><Call owner_token=None token=RetryTestEvent>", "self-><Group token=TestRetryWithEventBus type=Class>"]}, "node_9a11ae34": {"uid": "node_9a11ae34", "label": "640: test_retry_with_semaphore_on_multiple_handlers()", "name": "test_semaphores::TestRetryWithEventBus.test_retry_with_semaphore_on_multiple_handlers", "parent": "TestRetryWithEventBus", "is_leaf": false, "is_trunk": true, "source_code": null, "variables": ["BaseEvent->UNKNOWN_MODULE", "EventBus->UNKNOWN_MODULE", "bus-><Group token=EventBus type=Class>", "current_concurrent-><Call owner_token=None token=len>", "max_concurrent-><Call owner_token=None token=max>", "event-><Call owner_token=None token=WorkEvent>", "self-><Group token=TestRetryWithEventBus type=Class>"]}, "node_f2674407": {"uid": "node_f2674407", "label": "12: worker_acquire_semaphore()", "name": "test_semaphores::worker_acquire_semaphore", "parent": "test_semaphores", "is_leaf": false, "is_trunk": true, "source_code": "def worker_acquire_semaphore(\n    worker_id: int,\n    start_time: float,\n    results_queue: 'multiprocessing.Queue[Any]',\n    hold_time: float = 0.5,\n    timeout: float = 5.0,\n    should_release: bool = True,\n):\n    \"\"\"Worker process that tries to acquire a semaphore.\"\"\"\n    try:\n        print(f'Worker {worker_id} starting...')\n\n        # Define a function decorated with multiprocess semaphore\n        @retry(\n            retries=0,\n            timeout=10,\n            semaphore_limit=3,  # Only 3 concurrent processes allowed\n            semaphore_name='test_multiprocess_sem',\n            semaphore_scope='multiprocess',\n            semaphore_timeout=timeout,\n            semaphore_lax=False,  # Strict mode - must acquire semaphore\n        )\n        async def semaphore_protected_function():\n            acquire_time = time.time() - start_time\n            results_queue.put(('acquired', worker_id, acquire_time))\n\n            # Hold the semaphore for a bit\n            await asyncio.sleep(hold_time)\n\n            release_time = time.time() - start_time\n            results_queue.put(('released', worker_id, release_time))\n            return f'Worker {worker_id} completed'\n\n        # Run the async function\n        print(f'Worker {worker_id} running async function...')\n        result = asyncio.run(semaphore_protected_function())\n        print(f'Worker {worker_id} completed with result: {result}')\n        results_queue.put(('completed', worker_id, result))\n\n    except TimeoutError as e:\n        timeout_time = time.time() - start_time\n        print(f'Worker {worker_id} timed out: {e}')\n        results_queue.put(('timeout', worker_id, timeout_time, str(e)))\n    except Exception as e:\n        error_time = time.time() - start_time\n        print(f'Worker {worker_id} error: {type(e).__name__}: {e}')\n        import traceback\n\n        traceback.print_exc()\n        results_queue.put(('error', worker_id, error_time, str(e)))", "variables": ["result-><Call owner_token=asyncio token=run>", "traceback->UNKNOWN_MODULE"]}, "node_73dce271": {"uid": "node_73dce271", "label": "99: worker_death_test_normal()", "name": "test_semaphores::worker_death_test_normal", "parent": "test_semaphores", "is_leaf": false, "is_trunk": true, "source_code": "def worker_death_test_normal(\n    worker_id: int,\n    start_time: float,\n    results_queue: 'multiprocessing.Queue[Any]',\n):\n    \"\"\"Worker for death test that uses the same semaphore.\"\"\"\n\n    @retry(\n        retries=0,\n        timeout=10,\n        semaphore_limit=2,\n        semaphore_name='test_death_sem',\n        semaphore_scope='multiprocess',\n        semaphore_timeout=5.0,\n        semaphore_lax=False,\n    )\n    async def semaphore_protected_function():\n        acquire_time = time.time() - start_time\n        results_queue.put(('acquired', worker_id, acquire_time))\n        await asyncio.sleep(0.2)\n        release_time = time.time() - start_time\n        results_queue.put(('released', worker_id, release_time))\n        return f'Worker {worker_id} completed'\n\n    try:\n        result = asyncio.run(semaphore_protected_function())\n        results_queue.put(('completed', worker_id, result))\n    except Exception as e:\n        error_time = time.time() - start_time\n        results_queue.put(('error', worker_id, error_time, str(e)))", "variables": ["result-><Call owner_token=asyncio token=run>"]}, "node_8fa37b3b": {"uid": "node_8fa37b3b", "label": "64: worker_that_dies()", "name": "test_semaphores::worker_that_dies", "parent": "test_semaphores", "is_leaf": false, "is_trunk": true, "source_code": "def worker_that_dies(\n    worker_id: int,\n    start_time: float,\n    results_queue: 'multiprocessing.Queue[Any]',\n    die_after: float = 0.2,\n):\n    \"\"\"Worker process that acquires semaphore then dies without releasing.\"\"\"\n    try:\n\n        @retry(\n            retries=0,\n            timeout=10,\n            semaphore_limit=2,  # Only 2 concurrent processes\n            semaphore_name='test_death_sem',\n            semaphore_scope='multiprocess',\n            semaphore_timeout=5.0,\n            semaphore_lax=False,\n        )\n        async def semaphore_protected_function():\n            acquire_time = time.time() - start_time\n            results_queue.put(('acquired', worker_id, acquire_time))\n\n            # Hold for a bit then simulate crash\n            await asyncio.sleep(die_after)\n\n            # Simulate unexpected death\n            os._exit(1)  # Hard exit without cleanup  # type: ignore[attr-defined]\n\n        asyncio.run(semaphore_protected_function())\n\n    except Exception as e:\n        error_time = time.time() - start_time\n        results_queue.put(('error', worker_id, error_time, str(e)))", "variables": []}, "node_5b7475f3": {"uid": "node_5b7475f3", "label": "131: worker_with_custom_limit()", "name": "test_semaphores::worker_with_custom_limit", "parent": "test_semaphores", "is_leaf": false, "is_trunk": true, "source_code": "def worker_with_custom_limit(\n    worker_id: int,\n    start_time: float,\n    results_queue: 'multiprocessing.Queue[Any]',\n    hold_time: float = 0.5,\n    timeout: float = 5.0,\n    semaphore_limit: int = 2,\n    semaphore_name: str = 'test_custom_sem',\n):\n    \"\"\"Worker process with customizable semaphore limit.\"\"\"\n    try:\n\n        @retry(\n            retries=0,\n            timeout=10,\n            semaphore_limit=semaphore_limit,\n            semaphore_name=semaphore_name,\n            semaphore_scope='multiprocess',\n            semaphore_timeout=timeout,\n            semaphore_lax=False,\n        )\n        async def semaphore_protected_function():\n            acquire_time = time.time() - start_time\n            results_queue.put(('acquired', worker_id, acquire_time))\n\n            # Hold the semaphore for a bit\n            await asyncio.sleep(hold_time)\n\n            release_time = time.time() - start_time\n            results_queue.put(('released', worker_id, release_time))\n            return f'Worker {worker_id} completed'\n\n        # Run the async function\n        result = asyncio.run(semaphore_protected_function())\n        results_queue.put(('completed', worker_id, result))\n\n    except TimeoutError as e:\n        timeout_time = time.time() - start_time\n        results_queue.put(('timeout', worker_id, timeout_time, str(e)))\n    except Exception as e:\n        error_time = time.time() - start_time\n        results_queue.put(('error', worker_id, error_time, str(e)))", "variables": ["result-><Call owner_token=asyncio token=run>"]}}, "edges": [{"source": "node_aa4ef5eb", "target": "node_373f1430", "directed": true}, {"source": "node_f4ddb094", "target": "node_6ab514fc", "directed": true}, {"source": "node_f4ddb094", "target": "node_26a84f5a", "directed": true}, {"source": "node_f4ddb094", "target": "node_6ef5fab2", "directed": true}, {"source": "node_f4ddb094", "target": "node_aa4ef5eb", "directed": true}, {"source": "node_f4ddb094", "target": "node_1783601c", "directed": true}, {"source": "node_f4ddb094", "target": "node_11b04846", "directed": true}, {"source": "node_f4ddb094", "target": "node_d6660ac4", "directed": true}, {"source": "node_f4ddb094", "target": "node_0bcbb603", "directed": true}, {"source": "node_f4ddb094", "target": "node_0bcbb603", "directed": true}, {"source": "node_0c9dcba2", "target": "node_a5437ae5", "directed": true}, {"source": "node_0c9dcba2", "target": "node_0c9dcba2", "directed": true}, {"source": "node_0c9dcba2", "target": "node_28018a59", "directed": true}, {"source": "node_0c9dcba2", "target": "node_5036f8b9", "directed": true}, {"source": "node_0c9dcba2", "target": "node_5036f8b9", "directed": true}, {"source": "node_5e3f8add", "target": "node_0c9dcba2", "directed": true}, {"source": "node_28018a59", "target": "node_f06114ab", "directed": true}, {"source": "node_28018a59", "target": "node_a5437ae5", "directed": true}, {"source": "node_28018a59", "target": "node_0c9dcba2", "directed": true}, {"source": "node_768a3c6d", "target": "node_534cb428", "directed": true}, {"source": "node_96a812c6", "target": "node_401c2577", "directed": true}, {"source": "node_96a812c6", "target": "node_c971e5ae", "directed": true}, {"source": "node_fc8b7d19", "target": "node_fc8b7d19", "directed": true}, {"source": "node_5a258cb0", "target": "node_0c9dcba2", "directed": true}, {"source": "node_f05f8f75", "target": "node_fc8b7d19", "directed": true}, {"source": "node_4f2ab8db", "target": "node_fc7c5b80", "directed": true}, {"source": "node_7fe487d2", "target": "node_3f457f31", "directed": true}, {"source": "node_7fe487d2", "target": "node_25ce7859", "directed": true}, {"source": "node_7fe487d2", "target": "node_4b82fa38", "directed": true}, {"source": "node_7fe487d2", "target": "node_5036f8b9", "directed": true}, {"source": "node_99cd6779", "target": "node_3f457f31", "directed": true}, {"source": "node_cef0fd15", "target": "node_28018a59", "directed": true}, {"source": "node_5036f8b9", "target": "node_401c2577", "directed": true}, {"source": "node_401c2577", "target": "node_401c2577", "directed": true}, {"source": "node_6bf01a78", "target": "node_40cc180e", "directed": true}, {"source": "node_40cc180e", "target": "node_40cc180e", "directed": true}, {"source": "node_c047ad91", "target": "node_3af19848", "directed": true}, {"source": "node_6816f88b", "target": "node_f05f8f75", "directed": true}, {"source": "node_6816f88b", "target": "node_4b82fa38", "directed": true}, {"source": "node_6816f88b", "target": "node_4b82fa38", "directed": true}, {"source": "node_6816f88b", "target": "node_cc1a3b6e", "directed": true}, {"source": "node_6816f88b", "target": "node_cc1a3b6e", "directed": true}, {"source": "node_6816f88b", "target": "node_c62d4c60", "directed": true}, {"source": "node_cc1a3b6e", "target": "node_7fe487d2", "directed": true}, {"source": "node_cc1a3b6e", "target": "node_7fe487d2", "directed": true}, {"source": "node_cc1a3b6e", "target": "node_7fe487d2", "directed": true}, {"source": "node_cc1a3b6e", "target": "node_25ce7859", "directed": true}, {"source": "node_cc1a3b6e", "target": "node_4b82fa38", "directed": true}, {"source": "node_cc1a3b6e", "target": "node_4b82fa38", "directed": true}, {"source": "node_cc1a3b6e", "target": "node_4b82fa38", "directed": true}, {"source": "node_cc1a3b6e", "target": "node_4b82fa38", "directed": true}, {"source": "node_cc1a3b6e", "target": "node_4b82fa38", "directed": true}, {"source": "node_cc1a3b6e", "target": "node_4b82fa38", "directed": true}, {"source": "node_cc1a3b6e", "target": "node_4b82fa38", "directed": true}, {"source": "node_cc1a3b6e", "target": "node_4b82fa38", "directed": true}, {"source": "node_cc1a3b6e", "target": "node_4b82fa38", "directed": true}, {"source": "node_cc1a3b6e", "target": "node_4b82fa38", "directed": true}, {"source": "node_c62d4c60", "target": "node_25ce7859", "directed": true}, {"source": "node_c62d4c60", "target": "node_4b82fa38", "directed": true}, {"source": "node_c62d4c60", "target": "node_5036f8b9", "directed": true}, {"source": "node_c62d4c60", "target": "node_5036f8b9", "directed": true}, {"source": "node_c62d4c60", "target": "node_f675afd0", "directed": true}, {"source": "node_7ba1912f", "target": "node_5036f8b9", "directed": true}, {"source": "node_225cd398", "target": "node_225cd398", "directed": true}, {"source": "node_4ec4defe", "target": "node_ca737f95", "directed": true}, {"source": "node_ca737f95", "target": "node_7ba1912f", "directed": true}, {"source": "node_ca737f95", "target": "node_c971e5ae", "directed": true}, {"source": "node_ca737f95", "target": "node_37ba54f4", "directed": true}, {"source": "node_c347e76a", "target": "node_c2b32b93", "directed": true}, {"source": "node_c347e76a", "target": "node_4ec4defe", "directed": true}, {"source": "node_f675afd0", "target": "node_25ce7859", "directed": true}, {"source": "node_f675afd0", "target": "node_4b82fa38", "directed": true}, {"source": "node_f675afd0", "target": "node_4b82fa38", "directed": true}, {"source": "node_f675afd0", "target": "node_4b82fa38", "directed": true}, {"source": "node_f675afd0", "target": "node_4b82fa38", "directed": true}, {"source": "node_f675afd0", "target": "node_4b82fa38", "directed": true}, {"source": "node_f675afd0", "target": "node_4b82fa38", "directed": true}, {"source": "node_f675afd0", "target": "node_225cd398", "directed": true}, {"source": "node_987455fb", "target": "node_5036f8b9", "directed": true}, {"source": "node_987455fb", "target": "node_40cc180e", "directed": true}, {"source": "node_987455fb", "target": "node_c347e76a", "directed": true}, {"source": "node_987455fb", "target": "node_2419c883", "directed": true}, {"source": "node_878e294b", "target": "node_5e66fd0d", "directed": true}, {"source": "node_878e294b", "target": "node_63ae605d", "directed": true}, {"source": "node_301cc7e4", "target": "node_5e3f8add", "directed": true}, {"source": "node_5b816109", "target": "node_4b82fa38", "directed": true}, {"source": "node_5b816109", "target": "node_4b82fa38", "directed": true}, {"source": "node_5b816109", "target": "node_4b82fa38", "directed": true}, {"source": "node_5b816109", "target": "node_5036f8b9", "directed": true}, {"source": "node_c971e5ae", "target": "node_f05f8f75", "directed": true}, {"source": "node_c971e5ae", "target": "node_684c62e9", "directed": true}, {"source": "node_c971e5ae", "target": "node_121fc3f6", "directed": true}, {"source": "node_c971e5ae", "target": "node_6816f88b", "directed": true}, {"source": "node_c971e5ae", "target": "node_c62d4c60", "directed": true}, {"source": "node_c971e5ae", "target": "node_2419c883", "directed": true}, {"source": "node_2ed9b2de", "target": "node_3af19848", "directed": true}, {"source": "node_2ed9b2de", "target": "node_5bcc7357", "directed": true}, {"source": "node_5bcc7357", "target": "node_c347e76a", "directed": true}, {"source": "node_a683e24a", "target": "node_5036f8b9", "directed": true}, {"source": "node_a683e24a", "target": "node_5f08574f", "directed": true}, {"source": "node_64be10f9", "target": "node_5036f8b9", "directed": true}, {"source": "node_64be10f9", "target": "node_5f08574f", "directed": true}, {"source": "node_b6931fc1", "target": "node_b6931fc1", "directed": true}, {"source": "node_37ba54f4", "target": "node_0a49c07d", "directed": true}, {"source": "node_c49aad0e", "target": "node_a22c83f0", "directed": true}, {"source": "node_c49aad0e", "target": "node_987455fb", "directed": true}, {"source": "node_c49aad0e", "target": "node_5e66fd0d", "directed": true}, {"source": "node_c49aad0e", "target": "node_5bcc7357", "directed": true}, {"source": "node_c49aad0e", "target": "node_535fd480", "directed": true}, {"source": "node_c49aad0e", "target": "node_535fd480", "directed": true}, {"source": "node_c49aad0e", "target": "node_535fd480", "directed": true}, {"source": "node_61a62a43", "target": "node_5036f8b9", "directed": true}, {"source": "node_61a62a43", "target": "node_5036f8b9", "directed": true}, {"source": "node_61a62a43", "target": "node_5036f8b9", "directed": true}, {"source": "node_61a62a43", "target": "node_a22c83f0", "directed": true}, {"source": "node_61a62a43", "target": "node_987455fb", "directed": true}, {"source": "node_61a62a43", "target": "node_987455fb", "directed": true}, {"source": "node_61a62a43", "target": "node_5e66fd0d", "directed": true}, {"source": "node_61a62a43", "target": "node_2ed9b2de", "directed": true}, {"source": "node_29f46801", "target": "node_a22c83f0", "directed": true}, {"source": "node_29f46801", "target": "node_987455fb", "directed": true}, {"source": "node_29f46801", "target": "node_5e66fd0d", "directed": true}, {"source": "node_29f46801", "target": "node_2ed9b2de", "directed": true}, {"source": "node_de2f7682", "target": "node_a22c83f0", "directed": true}, {"source": "node_de2f7682", "target": "node_987455fb", "directed": true}, {"source": "node_de2f7682", "target": "node_5e66fd0d", "directed": true}, {"source": "node_de2f7682", "target": "node_2ed9b2de", "directed": true}, {"source": "node_85d0bc5c", "target": "node_f05f8f75", "directed": true}, {"source": "node_85d0bc5c", "target": "node_7fe487d2", "directed": true}, {"source": "node_85d0bc5c", "target": "node_3f457f31", "directed": true}, {"source": "node_7a18352b", "target": "node_f05f8f75", "directed": true}, {"source": "node_9076ef0b", "target": "node_8df69732", "directed": true}, {"source": "node_8df69732", "target": "node_76ec5898", "directed": true}, {"source": "node_8df69732", "target": "node_ef1fd925", "directed": true}, {"source": "node_76ec5898", "target": "node_5e3f8add", "directed": true}, {"source": "node_76ec5898", "target": "node_5e3f8add", "directed": true}, {"source": "node_76ec5898", "target": "node_fc7c5b80", "directed": true}, {"source": "node_76ec5898", "target": "node_a22c83f0", "directed": true}, {"source": "node_76ec5898", "target": "node_a22c83f0", "directed": true}, {"source": "node_76ec5898", "target": "node_987455fb", "directed": true}, {"source": "node_76ec5898", "target": "node_987455fb", "directed": true}, {"source": "node_76ec5898", "target": "node_987455fb", "directed": true}, {"source": "node_76ec5898", "target": "node_5e66fd0d", "directed": true}, {"source": "node_76ec5898", "target": "node_5e66fd0d", "directed": true}, {"source": "node_76ec5898", "target": "node_5e66fd0d", "directed": true}, {"source": "node_76ec5898", "target": "node_2ed9b2de", "directed": true}, {"source": "node_76ec5898", "target": "node_2ed9b2de", "directed": true}, {"source": "node_76ec5898", "target": "node_5bcc7357", "directed": true}, {"source": "node_76ec5898", "target": "node_5bcc7357", "directed": true}, {"source": "node_ef1fd925", "target": "node_5e3f8add", "directed": true}, {"source": "node_ef1fd925", "target": "node_5e3f8add", "directed": true}, {"source": "node_ef1fd925", "target": "node_a22c83f0", "directed": true}, {"source": "node_ef1fd925", "target": "node_a22c83f0", "directed": true}, {"source": "node_ef1fd925", "target": "node_987455fb", "directed": true}, {"source": "node_ef1fd925", "target": "node_987455fb", "directed": true}, {"source": "node_ef1fd925", "target": "node_987455fb", "directed": true}, {"source": "node_ef1fd925", "target": "node_5e66fd0d", "directed": true}, {"source": "node_ef1fd925", "target": "node_5e66fd0d", "directed": true}, {"source": "node_ef1fd925", "target": "node_5e66fd0d", "directed": true}, {"source": "node_ef1fd925", "target": "node_5e66fd0d", "directed": true}, {"source": "node_ef1fd925", "target": "node_5e66fd0d", "directed": true}, {"source": "node_ef1fd925", "target": "node_5e66fd0d", "directed": true}, {"source": "node_ef1fd925", "target": "node_5e66fd0d", "directed": true}, {"source": "node_ef1fd925", "target": "node_2ed9b2de", "directed": true}, {"source": "node_ef1fd925", "target": "node_2ed9b2de", "directed": true}, {"source": "node_ef1fd925", "target": "node_5bcc7357", "directed": true}, {"source": "node_ef1fd925", "target": "node_5bcc7357", "directed": true}, {"source": "node_c413ce57", "target": "node_a22c83f0", "directed": true}, {"source": "node_c413ce57", "target": "node_987455fb", "directed": true}, {"source": "node_c413ce57", "target": "node_987455fb", "directed": true}, {"source": "node_c413ce57", "target": "node_987455fb", "directed": true}, {"source": "node_c413ce57", "target": "node_5e66fd0d", "directed": true}, {"source": "node_c413ce57", "target": "node_5e66fd0d", "directed": true}, {"source": "node_c413ce57", "target": "node_5e66fd0d", "directed": true}, {"source": "node_c413ce57", "target": "node_2ed9b2de", "directed": true}, {"source": "node_f8e070dc", "target": "node_a22c83f0", "directed": true}, {"source": "node_f8e070dc", "target": "node_a22c83f0", "directed": true}, {"source": "node_f8e070dc", "target": "node_987455fb", "directed": true}, {"source": "node_f8e070dc", "target": "node_987455fb", "directed": true}, {"source": "node_f8e070dc", "target": "node_5e66fd0d", "directed": true}, {"source": "node_f8e070dc", "target": "node_5e66fd0d", "directed": true}, {"source": "node_f8e070dc", "target": "node_5e66fd0d", "directed": true}, {"source": "node_f8e070dc", "target": "node_2ed9b2de", "directed": true}, {"source": "node_f8e070dc", "target": "node_2ed9b2de", "directed": true}, {"source": "node_ce80632d", "target": "node_a22c83f0", "directed": true}, {"source": "node_ce80632d", "target": "node_a22c83f0", "directed": true}, {"source": "node_ce80632d", "target": "node_987455fb", "directed": true}, {"source": "node_ce80632d", "target": "node_987455fb", "directed": true}, {"source": "node_ce80632d", "target": "node_5e66fd0d", "directed": true}, {"source": "node_ce80632d", "target": "node_5e66fd0d", "directed": true}, {"source": "node_ce80632d", "target": "node_2ed9b2de", "directed": true}, {"source": "node_ce80632d", "target": "node_2ed9b2de", "directed": true}, {"source": "node_9ca5c1d5", "target": "node_a22c83f0", "directed": true}, {"source": "node_9ca5c1d5", "target": "node_987455fb", "directed": true}, {"source": "node_9ca5c1d5", "target": "node_987455fb", "directed": true}, {"source": "node_9ca5c1d5", "target": "node_5e66fd0d", "directed": true}, {"source": "node_9ca5c1d5", "target": "node_5e66fd0d", "directed": true}, {"source": "node_9ca5c1d5", "target": "node_2ed9b2de", "directed": true}, {"source": "node_94888df4", "target": "node_a22c83f0", "directed": true}, {"source": "node_94888df4", "target": "node_a22c83f0", "directed": true}, {"source": "node_94888df4", "target": "node_987455fb", "directed": true}, {"source": "node_94888df4", "target": "node_987455fb", "directed": true}, {"source": "node_94888df4", "target": "node_5e66fd0d", "directed": true}, {"source": "node_94888df4", "target": "node_5e66fd0d", "directed": true}, {"source": "node_94888df4", "target": "node_2ed9b2de", "directed": true}, {"source": "node_94888df4", "target": "node_2ed9b2de", "directed": true}, {"source": "node_e137faf3", "target": "node_a22c83f0", "directed": true}, {"source": "node_e137faf3", "target": "node_987455fb", "directed": true}, {"source": "node_e137faf3", "target": "node_2ed9b2de", "directed": true}, {"source": "node_71c53dc5", "target": "node_a22c83f0", "directed": true}, {"source": "node_71c53dc5", "target": "node_987455fb", "directed": true}, {"source": "node_71c53dc5", "target": "node_987455fb", "directed": true}, {"source": "node_71c53dc5", "target": "node_5e66fd0d", "directed": true}, {"source": "node_71c53dc5", "target": "node_2ed9b2de", "directed": true}, {"source": "node_ff513596", "target": "node_a22c83f0", "directed": true}, {"source": "node_ff513596", "target": "node_a22c83f0", "directed": true}, {"source": "node_ff513596", "target": "node_987455fb", "directed": true}, {"source": "node_ff513596", "target": "node_5e66fd0d", "directed": true}, {"source": "node_ff513596", "target": "node_5e66fd0d", "directed": true}, {"source": "node_ff513596", "target": "node_2ed9b2de", "directed": true}, {"source": "node_ff513596", "target": "node_2ed9b2de", "directed": true}, {"source": "node_ddf17b63", "target": "node_987455fb", "directed": true}, {"source": "node_dc02b64d", "target": "node_99cd6779", "directed": true}, {"source": "node_dc02b64d", "target": "node_1a0a2a24", "directed": true}, {"source": "node_dc02b64d", "target": "node_a22c83f0", "directed": true}, {"source": "node_dc02b64d", "target": "node_a22c83f0", "directed": true}, {"source": "node_dc02b64d", "target": "node_a22c83f0", "directed": true}, {"source": "node_dc02b64d", "target": "node_987455fb", "directed": true}, {"source": "node_dc02b64d", "target": "node_5e66fd0d", "directed": true}, {"source": "node_dc02b64d", "target": "node_5e66fd0d", "directed": true}, {"source": "node_dc02b64d", "target": "node_5e66fd0d", "directed": true}, {"source": "node_dc02b64d", "target": "node_5e66fd0d", "directed": true}, {"source": "node_dc02b64d", "target": "node_5e66fd0d", "directed": true}, {"source": "node_dc02b64d", "target": "node_5e66fd0d", "directed": true}, {"source": "node_dc02b64d", "target": "node_5e66fd0d", "directed": true}, {"source": "node_dc02b64d", "target": "node_2ed9b2de", "directed": true}, {"source": "node_dc02b64d", "target": "node_2ed9b2de", "directed": true}, {"source": "node_dc02b64d", "target": "node_5bcc7357", "directed": true}, {"source": "node_dc02b64d", "target": "node_5bcc7357", "directed": true}, {"source": "node_dc02b64d", "target": "node_5bcc7357", "directed": true}, {"source": "node_a9c20b50", "target": "node_987455fb", "directed": true}, {"source": "node_a9c20b50", "target": "node_5bcc7357", "directed": true}, {"source": "node_6bd81243", "target": "node_987455fb", "directed": true}, {"source": "node_a7930324", "target": "node_5036f8b9", "directed": true}, {"source": "node_a7930324", "target": "node_987455fb", "directed": true}, {"source": "node_a7930324", "target": "node_5bcc7357", "directed": true}, {"source": "node_8d040b3e", "target": "node_a22c83f0", "directed": true}, {"source": "node_8d040b3e", "target": "node_987455fb", "directed": true}, {"source": "node_8d040b3e", "target": "node_5e66fd0d", "directed": true}, {"source": "node_8d040b3e", "target": "node_2ed9b2de", "directed": true}, {"source": "node_f7d44e12", "target": "node_987455fb", "directed": true}, {"source": "node_d050b744", "target": "node_a22c83f0", "directed": true}, {"source": "node_d050b744", "target": "node_987455fb", "directed": true}, {"source": "node_d050b744", "target": "node_2ed9b2de", "directed": true}, {"source": "node_d050b744", "target": "node_2ed9b2de", "directed": true}, {"source": "node_d050b744", "target": "node_5bcc7357", "directed": true}, {"source": "node_712fa084", "target": "node_a22c83f0", "directed": true}, {"source": "node_253a79d8", "target": "node_a22c83f0", "directed": true}, {"source": "node_253a79d8", "target": "node_a22c83f0", "directed": true}, {"source": "node_253a79d8", "target": "node_987455fb", "directed": true}, {"source": "node_253a79d8", "target": "node_5e66fd0d", "directed": true}, {"source": "node_253a79d8", "target": "node_5e66fd0d", "directed": true}, {"source": "node_253a79d8", "target": "node_5e66fd0d", "directed": true}, {"source": "node_253a79d8", "target": "node_5e66fd0d", "directed": true}, {"source": "node_253a79d8", "target": "node_2ed9b2de", "directed": true}, {"source": "node_253a79d8", "target": "node_2ed9b2de", "directed": true}, {"source": "node_253a79d8", "target": "node_5bcc7357", "directed": true}, {"source": "node_253a79d8", "target": "node_5bcc7357", "directed": true}, {"source": "node_01da2c3c", "target": "node_a22c83f0", "directed": true}, {"source": "node_01da2c3c", "target": "node_a22c83f0", "directed": true}, {"source": "node_01da2c3c", "target": "node_a22c83f0", "directed": true}, {"source": "node_01da2c3c", "target": "node_987455fb", "directed": true}, {"source": "node_01da2c3c", "target": "node_5e66fd0d", "directed": true}, {"source": "node_01da2c3c", "target": "node_5e66fd0d", "directed": true}, {"source": "node_01da2c3c", "target": "node_5e66fd0d", "directed": true}, {"source": "node_01da2c3c", "target": "node_5e66fd0d", "directed": true}, {"source": "node_01da2c3c", "target": "node_5e66fd0d", "directed": true}, {"source": "node_01da2c3c", "target": "node_2ed9b2de", "directed": true}, {"source": "node_01da2c3c", "target": "node_2ed9b2de", "directed": true}, {"source": "node_01da2c3c", "target": "node_2ed9b2de", "directed": true}, {"source": "node_01da2c3c", "target": "node_5bcc7357", "directed": true}, {"source": "node_01da2c3c", "target": "node_5bcc7357", "directed": true}, {"source": "node_01da2c3c", "target": "node_5bcc7357", "directed": true}, {"source": "node_c38023ef", "target": "node_a22c83f0", "directed": true}, {"source": "node_c38023ef", "target": "node_a22c83f0", "directed": true}, {"source": "node_c38023ef", "target": "node_a22c83f0", "directed": true}, {"source": "node_c38023ef", "target": "node_987455fb", "directed": true}, {"source": "node_c38023ef", "target": "node_987455fb", "directed": true}, {"source": "node_c38023ef", "target": "node_5e66fd0d", "directed": true}, {"source": "node_c38023ef", "target": "node_5e66fd0d", "directed": true}, {"source": "node_c38023ef", "target": "node_5e66fd0d", "directed": true}, {"source": "node_c38023ef", "target": "node_5e66fd0d", "directed": true}, {"source": "node_c38023ef", "target": "node_5e66fd0d", "directed": true}, {"source": "node_c38023ef", "target": "node_5e66fd0d", "directed": true}, {"source": "node_c38023ef", "target": "node_2ed9b2de", "directed": true}, {"source": "node_c38023ef", "target": "node_2ed9b2de", "directed": true}, {"source": "node_c38023ef", "target": "node_2ed9b2de", "directed": true}, {"source": "node_c38023ef", "target": "node_5bcc7357", "directed": true}, {"source": "node_c38023ef", "target": "node_5bcc7357", "directed": true}, {"source": "node_c38023ef", "target": "node_5bcc7357", "directed": true}, {"source": "node_c38023ef", "target": "node_5bcc7357", "directed": true}, {"source": "node_c38023ef", "target": "node_5bcc7357", "directed": true}, {"source": "node_c38023ef", "target": "node_5bcc7357", "directed": true}, {"source": "node_241cff45", "target": "node_a22c83f0", "directed": true}, {"source": "node_241cff45", "target": "node_a22c83f0", "directed": true}, {"source": "node_241cff45", "target": "node_a22c83f0", "directed": true}, {"source": "node_241cff45", "target": "node_987455fb", "directed": true}, {"source": "node_241cff45", "target": "node_987455fb", "directed": true}, {"source": "node_241cff45", "target": "node_5e66fd0d", "directed": true}, {"source": "node_241cff45", "target": "node_5e66fd0d", "directed": true}, {"source": "node_241cff45", "target": "node_5e66fd0d", "directed": true}, {"source": "node_241cff45", "target": "node_5e66fd0d", "directed": true}, {"source": "node_241cff45", "target": "node_5e66fd0d", "directed": true}, {"source": "node_241cff45", "target": "node_2ed9b2de", "directed": true}, {"source": "node_241cff45", "target": "node_2ed9b2de", "directed": true}, {"source": "node_241cff45", "target": "node_2ed9b2de", "directed": true}, {"source": "node_241cff45", "target": "node_5bcc7357", "directed": true}, {"source": "node_241cff45", "target": "node_5bcc7357", "directed": true}, {"source": "node_241cff45", "target": "node_5bcc7357", "directed": true}, {"source": "node_241cff45", "target": "node_5bcc7357", "directed": true}, {"source": "node_241cff45", "target": "node_5bcc7357", "directed": true}, {"source": "node_cba19c72", "target": "node_987455fb", "directed": true}, {"source": "node_048aa0fd", "target": "node_987455fb", "directed": true}, {"source": "node_2612c774", "target": "node_a22c83f0", "directed": true}, {"source": "node_2612c774", "target": "node_987455fb", "directed": true}, {"source": "node_3b5bea0a", "target": "node_0ed329e3", "directed": true}, {"source": "node_3b5bea0a", "target": "node_987455fb", "directed": true}, {"source": "node_5c7e07ae", "target": "node_987455fb", "directed": true}, {"source": "node_cadf27d3", "target": "node_987455fb", "directed": true}, {"source": "node_d500d440", "target": "node_99cd6779", "directed": true}, {"source": "node_d500d440", "target": "node_987455fb", "directed": true}, {"source": "node_d500d440", "target": "node_987455fb", "directed": true}, {"source": "node_12e97416", "target": "node_987455fb", "directed": true}, {"source": "node_12e97416", "target": "node_987455fb", "directed": true}, {"source": "node_f7b0a85e", "target": "node_987455fb", "directed": true}, {"source": "node_0bf3ab27", "target": "node_99cd6779", "directed": true}, {"source": "node_0bf3ab27", "target": "node_99cd6779", "directed": true}, {"source": "node_0bf3ab27", "target": "node_987455fb", "directed": true}, {"source": "node_0bf3ab27", "target": "node_987455fb", "directed": true}, {"source": "node_c9fd4ab8", "target": "node_1a0a2a24", "directed": true}, {"source": "node_c9fd4ab8", "target": "node_1a0a2a24", "directed": true}, {"source": "node_c9fd4ab8", "target": "node_987455fb", "directed": true}, {"source": "node_c9fd4ab8", "target": "node_987455fb", "directed": true}, {"source": "node_68b00637", "target": "node_987455fb", "directed": true}, {"source": "node_f41b9575", "target": "node_987455fb", "directed": true}, {"source": "node_f41b9575", "target": "node_987455fb", "directed": true}, {"source": "node_f41b9575", "target": "node_5bcc7357", "directed": true}, {"source": "node_3e7a5413", "target": "node_987455fb", "directed": true}, {"source": "node_0026066b", "target": "node_987455fb", "directed": true}, {"source": "node_642ca7f7", "target": "node_987455fb", "directed": true}, {"source": "node_642ca7f7", "target": "node_5bcc7357", "directed": true}, {"source": "node_9d304421", "target": "node_987455fb", "directed": true}, {"source": "node_9d304421", "target": "node_878e294b", "directed": true}, {"source": "node_038b752d", "target": "node_5036f8b9", "directed": true}, {"source": "node_038b752d", "target": "node_5036f8b9", "directed": true}, {"source": "node_038b752d", "target": "node_5036f8b9", "directed": true}, {"source": "node_038b752d", "target": "node_987455fb", "directed": true}, {"source": "node_038b752d", "target": "node_878e294b", "directed": true}, {"source": "node_038b752d", "target": "node_878e294b", "directed": true}, {"source": "node_733ef27f", "target": "node_a22c83f0", "directed": true}, {"source": "node_733ef27f", "target": "node_987455fb", "directed": true}, {"source": "node_733ef27f", "target": "node_878e294b", "directed": true}, {"source": "node_733ef27f", "target": "node_2ed9b2de", "directed": true}, {"source": "node_d2efc9ce", "target": "node_987455fb", "directed": true}, {"source": "node_d2efc9ce", "target": "node_878e294b", "directed": true}, {"source": "node_aebe1a62", "target": "node_878e294b", "directed": true}, {"source": "node_e6995eab", "target": "node_987455fb", "directed": true}, {"source": "node_e6995eab", "target": "node_987455fb", "directed": true}, {"source": "node_e6995eab", "target": "node_987455fb", "directed": true}, {"source": "node_e6995eab", "target": "node_987455fb", "directed": true}, {"source": "node_e6995eab", "target": "node_878e294b", "directed": true}, {"source": "node_a954efc3", "target": "node_987455fb", "directed": true}, {"source": "node_a954efc3", "target": "node_987455fb", "directed": true}, {"source": "node_a954efc3", "target": "node_878e294b", "directed": true}, {"source": "node_8d8b0707", "target": "node_987455fb", "directed": true}, {"source": "node_8d8b0707", "target": "node_987455fb", "directed": true}, {"source": "node_8d8b0707", "target": "node_987455fb", "directed": true}, {"source": "node_8d8b0707", "target": "node_987455fb", "directed": true}, {"source": "node_8d8b0707", "target": "node_987455fb", "directed": true}, {"source": "node_8d8b0707", "target": "node_878e294b", "directed": true}, {"source": "node_d366670c", "target": "node_987455fb", "directed": true}, {"source": "node_d366670c", "target": "node_987455fb", "directed": true}, {"source": "node_d366670c", "target": "node_987455fb", "directed": true}, {"source": "node_d366670c", "target": "node_878e294b", "directed": true}, {"source": "node_d366670c", "target": "node_878e294b", "directed": true}, {"source": "node_d366670c", "target": "node_878e294b", "directed": true}, {"source": "node_d366670c", "target": "node_5bcc7357", "directed": true}, {"source": "node_6825d133", "target": "node_5036f8b9", "directed": true}, {"source": "node_6825d133", "target": "node_987455fb", "directed": true}, {"source": "node_6825d133", "target": "node_5bcc7357", "directed": true}, {"source": "node_d6cb9cd8", "target": "node_fc7c5b80", "directed": true}, {"source": "node_d6cb9cd8", "target": "node_5036f8b9", "directed": true}, {"source": "node_d6cb9cd8", "target": "node_5036f8b9", "directed": true}, {"source": "node_d6cb9cd8", "target": "node_5036f8b9", "directed": true}, {"source": "node_d6cb9cd8", "target": "node_5036f8b9", "directed": true}, {"source": "node_d6cb9cd8", "target": "node_5036f8b9", "directed": true}, {"source": "node_d6cb9cd8", "target": "node_987455fb", "directed": true}, {"source": "node_dd88d50a", "target": "node_a22c83f0", "directed": true}, {"source": "node_dd88d50a", "target": "node_5e66fd0d", "directed": true}, {"source": "node_dd88d50a", "target": "node_5e66fd0d", "directed": true}, {"source": "node_9ee39f9b", "target": "node_987455fb", "directed": true}, {"source": "node_9ee39f9b", "target": "node_987455fb", "directed": true}, {"source": "node_9ee39f9b", "target": "node_5bcc7357", "directed": true}, {"source": "node_fb05839a", "target": "node_987455fb", "directed": true}, {"source": "node_a602a0ec", "target": "node_a22c83f0", "directed": true}, {"source": "node_a602a0ec", "target": "node_987455fb", "directed": true}, {"source": "node_a602a0ec", "target": "node_2ed9b2de", "directed": true}, {"source": "node_a602a0ec", "target": "node_5bcc7357", "directed": true}, {"source": "node_05bb60e2", "target": "node_a22c83f0", "directed": true}, {"source": "node_05bb60e2", "target": "node_987455fb", "directed": true}, {"source": "node_05bb60e2", "target": "node_2ed9b2de", "directed": true}, {"source": "node_05bb60e2", "target": "node_5bcc7357", "directed": true}, {"source": "node_64af79cd", "target": "node_a22c83f0", "directed": true}, {"source": "node_64af79cd", "target": "node_987455fb", "directed": true}, {"source": "node_64af79cd", "target": "node_5e66fd0d", "directed": true}, {"source": "node_64af79cd", "target": "node_2ed9b2de", "directed": true}, {"source": "node_64af79cd", "target": "node_5bcc7357", "directed": true}, {"source": "node_7f04e1c6", "target": "node_987455fb", "directed": true}, {"source": "node_7f04e1c6", "target": "node_5bcc7357", "directed": true}, {"source": "node_eb143f95", "target": "node_a22c83f0", "directed": true}, {"source": "node_eb143f95", "target": "node_2ed9b2de", "directed": true}, {"source": "node_8b076e53", "target": "node_fe2341cc", "directed": true}, {"source": "node_506e63e3", "target": "node_a22c83f0", "directed": true}, {"source": "node_506e63e3", "target": "node_2ed9b2de", "directed": true}, {"source": "node_c5ef864d", "target": "node_a22c83f0", "directed": true}, {"source": "node_c5ef864d", "target": "node_301cc7e4", "directed": true}, {"source": "node_29f27802", "target": "node_a22c83f0", "directed": true}, {"source": "node_29f27802", "target": "node_301cc7e4", "directed": true}, {"source": "node_b2c37c79", "target": "node_a22c83f0", "directed": true}, {"source": "node_b2c37c79", "target": "node_301cc7e4", "directed": true}, {"source": "node_24d7b799", "target": "node_a22c83f0", "directed": true}, {"source": "node_24d7b799", "target": "node_301cc7e4", "directed": true}, {"source": "node_44b539ff", "target": "node_a22c83f0", "directed": true}, {"source": "node_44b539ff", "target": "node_301cc7e4", "directed": true}, {"source": "node_ab41b685", "target": "node_a22c83f0", "directed": true}, {"source": "node_ab41b685", "target": "node_301cc7e4", "directed": true}, {"source": "node_369c2399", "target": "node_a22c83f0", "directed": true}, {"source": "node_369c2399", "target": "node_301cc7e4", "directed": true}, {"source": "node_d30f35f9", "target": "node_a22c83f0", "directed": true}, {"source": "node_d30f35f9", "target": "node_301cc7e4", "directed": true}, {"source": "node_1dae6dea", "target": "node_a22c83f0", "directed": true}, {"source": "node_1dae6dea", "target": "node_a22c83f0", "directed": true}, {"source": "node_f62cc789", "target": "node_a22c83f0", "directed": true}, {"source": "node_f62cc789", "target": "node_a22c83f0", "directed": true}, {"source": "node_03d78f82", "target": "node_a22c83f0", "directed": true}, {"source": "node_03d78f82", "target": "node_a22c83f0", "directed": true}, {"source": "node_03d78f82", "target": "node_a22c83f0", "directed": true}, {"source": "node_03d78f82", "target": "node_a22c83f0", "directed": true}, {"source": "node_03d78f82", "target": "node_a22c83f0", "directed": true}, {"source": "node_03d78f82", "target": "node_a22c83f0", "directed": true}, {"source": "node_03d78f82", "target": "node_a22c83f0", "directed": true}, {"source": "node_03d78f82", "target": "node_a22c83f0", "directed": true}, {"source": "node_97cb342f", "target": "node_a22c83f0", "directed": true}, {"source": "node_97cb342f", "target": "node_a22c83f0", "directed": true}, {"source": "node_97cb342f", "target": "node_2ed9b2de", "directed": true}, {"source": "node_21815d1e", "target": "node_a22c83f0", "directed": true}, {"source": "node_21815d1e", "target": "node_a22c83f0", "directed": true}, {"source": "node_52241b57", "target": "node_a22c83f0", "directed": true}, {"source": "node_52241b57", "target": "node_a22c83f0", "directed": true}, {"source": "node_dbd68930", "target": "node_a22c83f0", "directed": true}, {"source": "node_dbd68930", "target": "node_a22c83f0", "directed": true}, {"source": "node_baa2c259", "target": "node_a22c83f0", "directed": true}, {"source": "node_baa2c259", "target": "node_a22c83f0", "directed": true}, {"source": "node_8212364e", "target": "node_a22c83f0", "directed": true}, {"source": "node_8212364e", "target": "node_a22c83f0", "directed": true}, {"source": "node_8212364e", "target": "node_a22c83f0", "directed": true}, {"source": "node_c8d965b8", "target": "node_987455fb", "directed": true}, {"source": "node_c8d965b8", "target": "node_987455fb", "directed": true}, {"source": "node_c8d965b8", "target": "node_5bcc7357", "directed": true}, {"source": "node_5b5bc21a", "target": "node_a22c83f0", "directed": true}, {"source": "node_5b5bc21a", "target": "node_a22c83f0", "directed": true}, {"source": "node_5b5bc21a", "target": "node_987455fb", "directed": true}, {"source": "node_5b5bc21a", "target": "node_987455fb", "directed": true}, {"source": "node_5b5bc21a", "target": "node_5e66fd0d", "directed": true}, {"source": "node_5b5bc21a", "target": "node_5e66fd0d", "directed": true}, {"source": "node_5b5bc21a", "target": "node_2ed9b2de", "directed": true}, {"source": "node_5b5bc21a", "target": "node_2ed9b2de", "directed": true}, {"source": "node_5b5bc21a", "target": "node_5bcc7357", "directed": true}, {"source": "node_5b5bc21a", "target": "node_5bcc7357", "directed": true}, {"source": "node_09730a51", "target": "node_987455fb", "directed": true}, {"source": "node_09730a51", "target": "node_987455fb", "directed": true}, {"source": "node_09730a51", "target": "node_987455fb", "directed": true}, {"source": "node_09730a51", "target": "node_5bcc7357", "directed": true}, {"source": "node_1ee5dbaf", "target": "node_987455fb", "directed": true}, {"source": "node_1ee5dbaf", "target": "node_987455fb", "directed": true}, {"source": "node_1ee5dbaf", "target": "node_5bcc7357", "directed": true}, {"source": "node_cee73279", "target": "node_987455fb", "directed": true}, {"source": "node_cee73279", "target": "node_987455fb", "directed": true}, {"source": "node_cee73279", "target": "node_987455fb", "directed": true}, {"source": "node_cee73279", "target": "node_5bcc7357", "directed": true}, {"source": "node_1e15eda0", "target": "node_987455fb", "directed": true}, {"source": "node_1e15eda0", "target": "node_987455fb", "directed": true}, {"source": "node_1e15eda0", "target": "node_5bcc7357", "directed": true}, {"source": "node_9a317753", "target": "node_987455fb", "directed": true}, {"source": "node_9a317753", "target": "node_987455fb", "directed": true}, {"source": "node_9a317753", "target": "node_987455fb", "directed": true}, {"source": "node_9a317753", "target": "node_5bcc7357", "directed": true}, {"source": "node_9155d7ea", "target": "node_987455fb", "directed": true}, {"source": "node_9155d7ea", "target": "node_987455fb", "directed": true}, {"source": "node_9155d7ea", "target": "node_5bcc7357", "directed": true}, {"source": "node_f89333cb", "target": "node_a22c83f0", "directed": true}, {"source": "node_f89333cb", "target": "node_2ed9b2de", "directed": true}, {"source": "node_f5020787", "target": "node_5036f8b9", "directed": true}, {"source": "node_24c55f61", "target": "node_5036f8b9", "directed": true}, {"source": "node_b33ef3d5", "target": "node_5036f8b9", "directed": true}, {"source": "node_9a47a820", "target": "node_5036f8b9", "directed": true}, {"source": "node_8f56a8c6", "target": "node_5036f8b9", "directed": true}, {"source": "node_0c047fb5", "target": "node_f4ddb094", "directed": true}, {"source": "node_f16c3b28", "target": "node_f4ddb094", "directed": true}, {"source": "node_658acb00", "target": "node_f4ddb094", "directed": true}, {"source": "node_c09f68c0", "target": "node_f4ddb094", "directed": true}, {"source": "node_c09f68c0", "target": "node_4f2ab8db", "directed": true}, {"source": "node_c09f68c0", "target": "node_a22c83f0", "directed": true}, {"source": "node_c09f68c0", "target": "node_987455fb", "directed": true}, {"source": "node_c09f68c0", "target": "node_5e66fd0d", "directed": true}, {"source": "node_c09f68c0", "target": "node_2ed9b2de", "directed": true}, {"source": "node_c09f68c0", "target": "node_5bcc7357", "directed": true}, {"source": "node_d6a04c1e", "target": "node_f4ddb094", "directed": true}, {"source": "node_d6a04c1e", "target": "node_a22c83f0", "directed": true}, {"source": "node_d6a04c1e", "target": "node_987455fb", "directed": true}, {"source": "node_d6a04c1e", "target": "node_5e66fd0d", "directed": true}, {"source": "node_d6a04c1e", "target": "node_2ed9b2de", "directed": true}, {"source": "node_d6a04c1e", "target": "node_5bcc7357", "directed": true}, {"source": "node_7b4df7f5", "target": "node_f4ddb094", "directed": true}, {"source": "node_7b4df7f5", "target": "node_a22c83f0", "directed": true}, {"source": "node_7b4df7f5", "target": "node_987455fb", "directed": true}, {"source": "node_7b4df7f5", "target": "node_5e66fd0d", "directed": true}, {"source": "node_7b4df7f5", "target": "node_2ed9b2de", "directed": true}, {"source": "node_7b4df7f5", "target": "node_5bcc7357", "directed": true}, {"source": "node_9a11ae34", "target": "node_f4ddb094", "directed": true}, {"source": "node_9a11ae34", "target": "node_a22c83f0", "directed": true}, {"source": "node_9a11ae34", "target": "node_987455fb", "directed": true}, {"source": "node_9a11ae34", "target": "node_5e66fd0d", "directed": true}, {"source": "node_9a11ae34", "target": "node_2ed9b2de", "directed": true}, {"source": "node_9a11ae34", "target": "node_5bcc7357", "directed": true}, {"source": "node_f2674407", "target": "node_f4ddb094", "directed": true}, {"source": "node_f2674407", "target": "node_6bf01a78", "directed": true}, {"source": "node_f2674407", "target": "node_6bf01a78", "directed": true}, {"source": "node_f2674407", "target": "node_6bf01a78", "directed": true}, {"source": "node_f2674407", "target": "node_6bf01a78", "directed": true}, {"source": "node_f2674407", "target": "node_6bf01a78", "directed": true}, {"source": "node_73dce271", "target": "node_f4ddb094", "directed": true}, {"source": "node_73dce271", "target": "node_6bf01a78", "directed": true}, {"source": "node_73dce271", "target": "node_6bf01a78", "directed": true}, {"source": "node_73dce271", "target": "node_6bf01a78", "directed": true}, {"source": "node_73dce271", "target": "node_6bf01a78", "directed": true}, {"source": "node_8fa37b3b", "target": "node_f4ddb094", "directed": true}, {"source": "node_8fa37b3b", "target": "node_6bf01a78", "directed": true}, {"source": "node_8fa37b3b", "target": "node_6bf01a78", "directed": true}, {"source": "node_5b7475f3", "target": "node_f4ddb094", "directed": true}, {"source": "node_5b7475f3", "target": "node_6bf01a78", "directed": true}, {"source": "node_5b7475f3", "target": "node_6bf01a78", "directed": true}, {"source": "node_5b7475f3", "target": "node_6bf01a78", "directed": true}, {"source": "node_5b7475f3", "target": "node_6bf01a78", "directed": true}, {"source": "node_5b7475f3", "target": "node_6bf01a78", "directed": true}]}}